export interface Question {
  id: number;
  category: string;
  question: string;
  answer: string;
  example?: string;
}

export const categories = [
  "Barcha savollar",
  "Programming Basics (Beginner)",
  "How Java Works (Intermediate)",
  "Java Fundamentals",
  "OOP",
  "Collections",
  "Multithreading (Junior)",
  "Concurrency (Middle)",
  "Advanced Threading (Senior)",
  "Exception Handling",
  "Stream API",
  "JVM",
  "Generics",
  "SOLID",
  "Best Practices",
  "Spring Core (Junior)",
  "Spring Boot (Junior)",
  "Spring MVC (Middle)",
  "Spring Data JPA (Middle)",
  "Spring Security (Senior)",
  "Spring Advanced (Senior)"
];

export const questions: Question[] = [
  // Programming Basics (Beginner)
  {
    id: 1,
    category: "Programming Basics (Beginner)",
    question: "Dasturlash nima va dasturchi nima qiladi?",
    answer: "Dasturlash - bu kompyuterga nima qilish kerakligini aytish san'ati. Dasturchi kompyuter tushunadigan tillar (programming languages) yordamida muammolarni hal qilish uchun ko'rsatmalar (instructions) yozadi. Dasturchi muammoni tahlil qiladi, yechim topadi, uni kodga aylantiradi va test qiladi. Dasturchi yangi dasturlar yaratadi, mavjud dasturlarni yaxshilaydi, xatolarni tuzatadi va foydalanuvchilarning ehtiyojlarini qondiradi.",
    example: "// Oddiy dastur - kompyuterga 'Hello World' yozishni aytish\nSystem.out.println(\"Hello World\");\n\n// Dasturchi bu yerda:\n// 1. Muammoni tushundi: ekranga matn chiqarish kerak\n// 2. Yechim topdi: println metodidan foydalanish\n// 3. Kodni yozdi: System.out.println(...)\n// 4. Natija: 'Hello World' ekranda ko'rinadi"
  },
  {
    id: 2,
    category: "Programming Basics (Beginner)",
    question: "Variable (o'zgaruvchi) nima va nima uchun kerak?",
    answer: "Variable - bu ma'lumotni saqlash uchun nom berilgan joy (container). Xuddi qutiga nom yozib, ichiga biror narsa qo'yish kabi. Variable qiymatni eslab qolish va keyinroq ishlatish uchun kerak. Har bir variable ning: 1) Nomi (identifier) - masalan 'age'. 2) Tipi (type) - qanday ma'lumot saqlashi (int, String va h.k.). 3) Qiymati (value) - hozirgi saqlangan ma'lumot. Variable lar dastur davomida o'zgarishi mumkin (shuning uchun 'o'zgaruvchi').",
    example: "// Variable yaratish va ishlatish\nint age = 25;           // 'age' nomli o'zgaruvchi, qiymati 25\nString name = \"Ali\";    // 'name' nomli o'zgaruvchi, qiymati \"Ali\"\n\n// Variable ni o'zgartirish\nage = 26;               // Endi age = 26\n\n// Variable dan foydalanish\nSystem.out.println(\"Mening yoshim: \" + age);\nSystem.out.println(\"Mening ismim: \" + name);\n\n// Real hayot misoli:\nint price = 10000;      // Mahsulot narxi\nint quantity = 3;       // Miqdor\nint total = price * quantity;  // Jami: 30000"
  },
  {
    id: 3,
    category: "Programming Basics (Beginner)",
    question: "Data type (ma'lumot turi) nima va asosiy turlar qanday?",
    answer: "Data type - bu qanday turdagi ma'lumot saqlanishini ko'rsatadi. Har xil ma'lumotlar uchun har xil tiplar mavjud. Asosiy turlar: 1) Integer (int) - butun sonlar (-5, 0, 42). 2) Double/Float - o'nlik sonlar (3.14, -2.5). 3) Boolean - true yoki false. 4) Character (char) - bitta harf ('A', 'b'). 5) String - matn ('Hello', 'Java'). Har bir tip qancha joy egallashi va qanday operatsiyalar qilish mumkinligini belgilaydi.",
    example: "// Har xil data typelar\nint studentCount = 30;        // Butun son\ndouble temperature = 36.6;    // O'nlik son\nboolean isRaining = true;     // Ha/Yo'q (true/false)\nchar grade = 'A';             // Bitta belgi\nString message = \"Salom\";     // Matn\n\n// Nima uchun to'g'ri type tanlash muhim:\nint price = 100;              // To'g'ri - narx butun son\n// String price = \"100\";      // Noto'g'ri - hisoblash qilib bo'lmaydi!\n\n// Type bilan operatsiyalar\nint a = 10;\nint b = 5;\nint sum = a + b;              // 15 - matematika\n\nString firstName = \"Ali\";\nString lastName = \"Valiyev\";\nString fullName = firstName + \" \" + lastName;  // \"Ali Valiyev\" - birlashtirish"
  },
  {
    id: 4,
    category: "Programming Basics (Beginner)",
    question: "Operators (operatorlar) nima va qanday turlari bor?",
    answer: "Operators - bu ma'lumotlar ustida operatsiyalar bajarish uchun belgilar. Asosiy turlari: 1) Arithmetic (arifmetik) - +, -, *, /, % (matematika). 2) Comparison (solishtirish) - ==, !=, >, <, >=, <= (taqqoslash). 3) Logical (mantiqiy) - && (va), || (yoki), ! (emas). 4) Assignment (tayinlash) - = (qiymat berish). 5) Increment/Decrement - ++, -- (oshirish/kamaytirish). Operatorlar ifodalar (expressions) yaratishga yordam beradi.",
    example: "// Arithmetic operators\nint x = 10 + 5;      // 15 - qo'shish\nint y = 10 - 5;      // 5 - ayirish\nint z = 10 * 5;      // 50 - ko'paytirish\nint w = 10 / 5;      // 2 - bo'lish\nint r = 10 % 3;      // 1 - qoldiq (10 ni 3 ga bo'lganda qoldiq)\n\n// Comparison operators\nboolean isEqual = (5 == 5);        // true\nboolean isNotEqual = (5 != 3);     // true\nboolean isGreater = (10 > 5);      // true\nboolean isLess = (3 < 5);          // true\n\n// Logical operators\nboolean result1 = (5 > 3) && (10 > 8);   // true - ikkisi ham true\nboolean result2 = (5 > 3) || (10 < 8);   // true - kamida bittasi true\nboolean result3 = !(5 > 3);              // false - teskarisi\n\n// Real misol: Magazin\nint price = 50000;\nint discount = 10000;\nint finalPrice = price - discount;   // 40000\nboolean canBuy = finalPrice <= 50000;  // true"
  },
  {
    id: 5,
    category: "Programming Basics (Beginner)",
    question: "If statement (shart operatori) qanday ishlaydi?",
    answer: "If statement - bu shartga qarab qaror qabul qilish mexanizmi. 'Agar ... bo'lsa, ...' mantiqida ishlaydi. Agar shart true bo'lsa, kod bajariladi, aks holda o'tkazib yuboriladi. if-else bilan ikki variant, if-else if-else bilan ko'p variant. Har kuni hayotda qaror qabul qilish kabi: agar yomg'ir yog'sa, soyabon ol, aks holda soyabon kerak emas. Dasturlashda ham xuddi shunday mantiqiy qarorlar qabul qilinadi.",
    example: "// Oddiy if\nint age = 18;\nif (age >= 18) {\n    System.out.println(\"Siz voyaga yetgansiz\");\n}\n\n// if-else\nint temperature = 30;\nif (temperature > 25) {\n    System.out.println(\"Issiq\");\n} else {\n    System.out.println(\"Sovuq\");\n}\n\n// if-else if-else\nint score = 85;\nif (score >= 90) {\n    System.out.println(\"A'lo\");\n} else if (score >= 70) {\n    System.out.println(\"Yaxshi\");\n} else if (score >= 50) {\n    System.out.println(\"Qoniqarli\");\n} else {\n    System.out.println(\"Qoniqarsiz\");\n}\n\n// Real misol: Avtorizatsiya\nString username = \"ali\";\nString password = \"1234\";\n\nif (username.equals(\"ali\") && password.equals(\"1234\")) {\n    System.out.println(\"Xush kelibsiz!\");\n} else {\n    System.out.println(\"Login yoki parol xato!\");\n}"
  },
  {
    id: 6,
    category: "Programming Basics (Beginner)",
    question: "Loop (sikl) nima va nima uchun kerak?",
    answer: "Loop - bu bir xil yoki o'xshash kodni qayta-qayta bajarish mexanizmi. Kod nusxa ko'chirmasdan bir necha marta bajarish imkonini beradi. 3 xil asosiy loop: 1) for loop - aniq sondagi takrorlash uchun. 2) while loop - shart true bo'lguncha. 3) do-while loop - kamida bir marta bajariladi. Loop siz 1000 marta 'Hello' yozish uchun 1000 qator kod yozish kerak bo'ladi! Loop bu ishni 3 qatorda hal qiladi.",
    example: "// for loop - aniq necha marta\nfor (int i = 1; i <= 5; i++) {\n    System.out.println(\"Salom \" + i);\n}\n// Natija: Salom 1, Salom 2, ... Salom 5\n\n// while loop - shart bo'yicha\nint count = 0;\nwhile (count < 3) {\n    System.out.println(\"Count: \" + count);\n    count++;\n}\n\n// do-while - kamida 1 marta\nint x = 10;\ndo {\n    System.out.println(\"x = \" + x);\n    x++;\n} while (x < 5);  // Shart false, lekin 1 marta bajarildi\n\n// Real misol: 1 dan 10 gacha yig'indi\nint sum = 0;\nfor (int i = 1; i <= 10; i++) {\n    sum = sum + i;\n}\nSystem.out.println(\"Yig'indi: \" + sum);  // 55\n\n// Real misol: Arraydan o'qish\nString[] names = {\"Ali\", \"Vali\", \"Salim\"};\nfor (int i = 0; i < names.length; i++) {\n    System.out.println(names[i]);\n}"
  },
  {
    id: 7,
    category: "Programming Basics (Beginner)",
    question: "Array (massiv) nima va qanday ishlatiladi?",
    answer: "Array - bu bir xil turdagi bir nechta ma'lumotlarni bitta nomda saqlash. Ro'yxat (list) kabi. Har bir element index (tartib raqam) orqali kirish mumkin. Index 0 dan boshlanadi! Array ning: 1) Fixed size - yaratilganda o'lchami belgilanadi. 2) Same type - barcha elementlar bir xil type. 3) Fast access - index bo'yicha tez kirish (O(1)). Array ko'p ma'lumotlarni tartibli saqlash va ular bilan ishlash uchun juda qulay.",
    example: "// Array yaratish va ishlatish\nint[] numbers = {10, 20, 30, 40, 50};\n\n// Element olish (index 0 dan boshlanadi!)\nint first = numbers[0];     // 10\nint second = numbers[1];    // 20\nint last = numbers[4];      // 50\n\n// Element o'zgartirish\nnumbers[2] = 35;            // 30 o'rniga 35\n\n// Array uzunligi\nint length = numbers.length;  // 5\n\n// Loop bilan ishlash\nfor (int i = 0; i < numbers.length; i++) {\n    System.out.println(numbers[i]);\n}\n\n// Real misol: Talabalar\nString[] students = new String[3];\nstudents[0] = \"Ali\";\nstudents[1] = \"Vali\";\nstudents[2] = \"Salim\";\n\n// Barcha talabalarni chiqarish\nfor (String student : students) {\n    System.out.println(\"Talaba: \" + student);\n}\n\n// Real misol: Baholar\nint[] grades = {85, 90, 78, 92, 88};\nint sum = 0;\nfor (int grade : grades) {\n    sum += grade;\n}\ndouble average = sum / (double) grades.length;\nSystem.out.println(\"O'rtacha baho: \" + average);"
  },
  {
    id: 8,
    category: "Programming Basics (Beginner)",
    question: "Function/Method nima va nima uchun kerak?",
    answer: "Function (yoki Method) - bu qayta ishlatilishi mumkin bo'lgan kod bloki. Muayyan vazifani bajaradi va nom bilan chaqiriladi. Function: 1) Input olishi mumkin (parameters). 2) Ishni bajaradi. 3) Output qaytarishi mumkin (return value). Function kod takrorlanishini kamaytiradi, kodni tushunarliroq qiladi va qayta ishlatish imkonini beradi. Bir marta yoz, ko'p joyda ishla! DRY principle: Don't Repeat Yourself.",
    example: "// Oddiy function\npublic static void greet() {\n    System.out.println(\"Salom!\");\n}\n\n// Function chaqirish\ngreet();  // Natija: Salom!\n\n// Parameter li function\npublic static void greetPerson(String name) {\n    System.out.println(\"Salom, \" + name + \"!\");\n}\n\ngreetPerson(\"Ali\");   // Salom, Ali!\ngreetPerson(\"Vali\");  // Salom, Vali!\n\n// Return qiluvchi function\npublic static int add(int a, int b) {\n    return a + b;\n}\n\nint result = add(5, 3);  // 8\n\n// Real misol: Hisoblash\npublic static double calculateTotal(double price, int quantity) {\n    return price * quantity;\n}\n\ndouble total1 = calculateTotal(10.5, 3);   // 31.5\ndouble total2 = calculateTotal(20.0, 2);   // 40.0\n\n// Real misol: Validation\npublic static boolean isValidAge(int age) {\n    return age >= 18 && age <= 100;\n}\n\nif (isValidAge(25)) {\n    System.out.println(\"Yosh to'g'ri\");\n}"
  },
  {
    id: 9,
    category: "Programming Basics (Beginner)",
    question: "Input va Output nima?",
    answer: "Input - bu dasturga tashqaridan kelgan ma'lumot (user dan, file dan, network dan). Output - bu dastur tomonidan chiqariladigan ma'lumot (ekranga, file ga, network ga). Input/Output (I/O) - dasturning tashqi dunyo bilan muloqoti. Dastur: Input oladi → Process qiladi → Output beradi. Misol: Calculator dasturi - siz sonlarni kiritasiz (input), dastur hisoblaydi (process), natijani ko'rsatadi (output).",
    example: "// Output - ekranga chiqarish\nSystem.out.println(\"Salom!\");           // Yangi qatorga\nSystem.out.print(\"Java\");               // Bir qatorda\nSystem.out.println(\" Programming\");     // Davomi\n\n// Input - Scanner bilan\nimport java.util.Scanner;\n\nScanner scanner = new Scanner(System.in);\n\n// Matn olish\nSystem.out.print(\"Ismingizni kiriting: \");\nString name = scanner.nextLine();\n\n// Son olish\nSystem.out.print(\"Yoshingizni kiriting: \");\nint age = scanner.nextInt();\n\n// Output berish\nSystem.out.println(\"Salom, \" + name + \"!\");\nSystem.out.println(\"Siz \" + age + \" yoshdasiz.\");\n\n// Real misol: Calculator\nSystem.out.print(\"Birinchi sonni kiriting: \");\nint num1 = scanner.nextInt();\n\nSystem.out.print(\"Ikkinchi sonni kiriting: \");\nint num2 = scanner.nextInt();\n\nint sum = num1 + num2;\nSystem.out.println(\"Yig'indi: \" + sum);\n\nscanner.close();  // Scanner ni yopish"
  },
  {
    id: 10,
    category: "Programming Basics (Beginner)",
    question: "Algorithm nima va qanday yoziladi?",
    answer: "Algorithm - bu muammoni hal qilish uchun qadam-baqadam ko'rsatmalar ketma-ketligi. Retsept kabi: avval bu, keyin u, oxirida natija. Yaxshi algorithm: 1) Aniq - har bir qadam tushunarli. 2) Cheklangan - oxiri bor. 3) Effective - ishlaydigan yechim beradi. Algorithm yozish: muammoni tushunish → kiritma va chiqarma aniqlash → qadamlarni rejalashtirish → pseudocode yozish → kodga aylantirish → test qilish.",
    example: "// Muammo: 2 ta sonning eng kattasini topish\n\n// Algorithm (pseudocode):\n// 1. Ikkita son ol: a va b\n// 2. Agar a > b bo'lsa\n//    - a ni chiqar\n// 3. Aks holda\n//    - b ni chiqar\n\n// Kod:\npublic static int findMax(int a, int b) {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n// Real misol: Array dagi eng katta element\npublic static int findMaxInArray(int[] arr) {\n    // Algorithm:\n    // 1. Birinchi elementni max deb ol\n    int max = arr[0];\n    \n    // 2. Har bir elementni tekshir\n    for (int i = 1; i < arr.length; i++) {\n        // 3. Agar joriy element kattaroq bo'lsa\n        if (arr[i] > max) {\n            // 4. Uni max qilib belgilaymiz\n            max = arr[i];\n        }\n    }\n    \n    // 5. max ni qaytaramiz\n    return max;\n}\n\nint[] numbers = {15, 8, 23, 42, 16};\nint largest = findMaxInArray(numbers);  // 42"
  },
  {
    id: 11,
    category: "Programming Basics (Beginner)",
    question: "Bug (xato) nima va qanday topiladi?",
    answer: "Bug - bu dasturda xato yoki kutilmagan xatti-harakat. 3 xil bug: 1) Syntax error - grammatik xato, kod ishlamaydi. 2) Runtime error - dastur ishlayotganda xato (masalan, 0 ga bo'lish). 3) Logic error - dastur ishlaydi, lekin noto'g'ri natija beradi. Debugging - buglarni topish va tuzatish jarayoni. Usullari: print statement lar qo'yish, debugger tool ishlatish, kod qadamba-qadam ko'rib chiqish, test case lar yozish. Bug topish - detektiv bo'lish kabi!",
    example: "// 1. Syntax Error - kod ishlamaydi\nint x = 5  // ; yo'q - syntax error!\nSystem.out.println(x)\n\n// 2. Runtime Error\nint a = 10;\nint b = 0;\nint result = a / b;  // ArithmeticException - 0 ga bo'lish!\n\n// 3. Logic Error - noto'g'ri natija\npublic static int calculateAverage(int a, int b) {\n    return a + b / 2;  // Xato! (a + b) / 2 bo'lishi kerak\n}\n// calculateAverage(10, 20) = 20 (noto'g'ri)\n// To'g'risi: (10 + 20) / 2 = 15\n\n// Debugging usuli: Print statements\npublic static int findSum(int[] arr) {\n    int sum = 0;\n    for (int i = 0; i < arr.length; i++) {\n        System.out.println(\"i = \" + i + \", arr[i] = \" + arr[i]);  // Debug\n        sum += arr[i];\n        System.out.println(\"sum = \" + sum);  // Debug\n    }\n    return sum;\n}\n\n// Tuzatish:\npublic static int calculateAverage(int a, int b) {\n    return (a + b) / 2;  // To'g'ri!\n}"
  },
  {
    id: 12,
    category: "Programming Basics (Beginner)",
    question: "Comment (izoh) nima va nima uchun yoziladi?",
    answer: "Comment - bu dasturchi uchun izoh, kompyuter uni o'qimaydi. Comment kod nima qilishini tushuntirish, murakkab joylarni izohlab berish uchun yoziladi. 2 xil comment: 1) Single-line comment (//) - bir qator izoh. 2) Multi-line comment (/* ... */) - ko'p qatorli izoh. Yaxshi comment kodni tushunarli qiladi, lekin ortiqcha comment kodning o'zini murakkablashtiradi. Kod 'nima qiladi' emas, 'nima uchun qiladi' ni tushuntirish kerak.",
    example: "// Single-line comment\nint age = 25;  // Foydalanuvchi yoshi\n\n// Kod nima qilishini tushuntirish\n// Foydalanuvchi yoshini tekshirish\nif (age >= 18) {\n    System.out.println(\"Voyaga yetgan\");\n}\n\n/* Multi-line comment\n   Bu funksiya ikkita sonning\n   yig'indisini hisoblab,\n   natijani qaytaradi */\npublic static int add(int a, int b) {\n    return a + b;\n}\n\n// Yaxshi comment\npublic static double calculateDiscount(double price, int customerType) {\n    // VIP mijozlar 20% chegirma oladi\n    if (customerType == VIP) {\n        return price * 0.8;\n    }\n    return price;\n}\n\n// Yomon comment (ortiqcha)\nint x = 5;  // x ga 5 qiymatini berish - Bu ayon!\n\n// Code disable qilish uchun\n// System.out.println(\"Test\");  // Vaqtincha o'chirilgan\n\n// TODO comment - kelajakda qilish kerak bo'lgan ish\npublic void processPayment() {\n    // TODO: Kredit karta validatsiyasini qo'shish\n    // TODO: Email yuborish funksiyasini implement qilish\n}"
  },
  {
    id: 13,
    category: "Programming Basics (Beginner)",
    question: "Pseudocode nima va qanday yoziladi?",
    answer: "Pseudocode - bu algoritmni oddiy, tushunarli tilda yozish. Real kod emas, lekin kod mantiqini ko'rsatadi. Hech qanday programming language ga bog'liq emas. Pseudocode muammoni hal qilish logikasini rejalashtirish uchun ishlatiladi. Avval pseudocode, keyin real kod. Pseudocode yozish: oddiy so'zlar, if/else/while kabi strukturalar, indentation (joy qoldirish), aniq va qisqa.",
    example: "// Muammo: Sonning toq yoki juftligini aniqlash\n\n// Pseudocode:\n/*\nBOSHLASH\n    son ni ol\n    AGAR son % 2 == 0 BO'LSA\n        \"Juft\" deb chiqar\n    AKS HOLDA\n        \"Toq\" deb chiqar\n    AGAR OXIRI\nTUGATISH\n*/\n\n// Real kod:\npublic static void checkEvenOdd(int number) {\n    if (number % 2 == 0) {\n        System.out.println(\"Juft\");\n    } else {\n        System.out.println(\"Toq\");\n    }\n}\n\n// Murakkab misol: Array dagi eng kichik element\n\n// Pseudocode:\n/*\nBOSHLASH\n    array ni ol\n    min = array ning birinchi elementi\n    \n    ARRAY ning har bir elementi UCHUN\n        AGAR element < min BO'LSA\n            min = element\n        AGAR OXIRI\n    UCHUN OXIRI\n    \n    min ni qaytarish\nTUGATISH\n*/\n\n// Real kod:\npublic static int findMin(int[] arr) {\n    int min = arr[0];\n    \n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n    }\n    \n    return min;\n}"
  },
  {
    id: 14,
    category: "Programming Basics (Beginner)",
    question: "Problem solving (muammo hal qilish) ko'nikmasi qanday rivojlantiriladi?",
    answer: "Problem solving - dasturlashning eng muhim ko'nikmasi. Bu faqat kod yozish emas, muammoni tushunish va yechim topish. Rivojlantirish usullari: 1) Muammoni to'liq tushunish - nima berilgan, nima topish kerak. 2) Kichik qismlarga bo'lish - katta muammoni kichik muammolarga. 3) Pattern lar topish - o'xshash muammolar yechilganmi. 4) Pseudocode yozish. 5) Ko'p mashq qilish - har xil muammolarni yechish. 6) Boshqalarning kodini o'rganish. Har kuni mashq qilish muhim!",
    example: "// Muammo: Palindrome tekshirish (\"sos\", \"non\" kabi)\n\n// 1. Muammoni tushunish\n// Input: String\n// Output: true/false\n// Palindrome: chapdan o'ngga = o'ngdan chapga\n\n// 2. Kichik qismlarga bo'lish\n// - Stringni teskari o'girish\n// - Original bilan solishtirish\n\n// 3. Pseudocode\n/*\nBOSHLASH\n    string ni ol\n    reversed = string ni teskari o'girish\n    AGAR string == reversed BO'LSA\n        true qaytarish\n    AKS HOLDA\n        false qaytarish\nTUGATISH\n*/\n\n// 4. Kod yozish\npublic static boolean isPalindrome(String str) {\n    String reversed = \"\";\n    \n    // Teskari o'girish\n    for (int i = str.length() - 1; i >= 0; i--) {\n        reversed += str.charAt(i);\n    }\n    \n    // Solishtirish\n    return str.equals(reversed);\n}\n\n// Test\nSystem.out.println(isPalindrome(\"sos\"));    // true\nSystem.out.println(isPalindrome(\"olma\"));   // false\n\n// 5. Yaxshilash (optimizatsiya)\npublic static boolean isPalindromeFast(String str) {\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str.charAt(left) != str.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}"
  },
  {
    id: 15,
    category: "Programming Basics (Beginner)",
    question: "Computer memory (xotira) qanday ishlaydi?",
    answer: "Computer memory - bu ma'lumotlarni saqlash joyi. 2 xil asosiy memory: 1) RAM (Random Access Memory) - tez, lekin vaqtinchalik. Dastur ishlaganda ishlatiladi, kompyuter o'chsa yo'qoladi. 2) Hard Disk/SSD - sekinroq, lekin doimiy. Fayllar bu yerda saqlanadi. RAM da: Stack (lokal o'zgaruvchilar) va Heap (obyektlar) mavjud. Memory cheklangan, shuning uchun efficient ishlatish kerak. Memory leak - ishlatilmagan memory ozod qilinmasa.",
    example: "// Stack memory - lokal o'zgaruvchilar\npublic static void main(String[] args) {\n    int x = 5;        // Stack da\n    int y = 10;       // Stack da\n    int sum = x + y;  // Stack da\n    \n    // Method tugagach, x, y, sum stack dan o'chiriladi\n}\n\n// Heap memory - obyektlar\npublic static void main(String[] args) {\n    String name = new String(\"Ali\");  // \"Ali\" heap da\n    int[] arr = new int[100];         // Array heap da\n    \n    // name va arr referencelar stack da\n    // Lekin ular ko'rsatgan ma'lumot heap da\n}\n\n// Memory leak misoli (Java da GC bor, lekin...)\nclass MemoryLeakExample {\n    private static List<byte[]> list = new ArrayList<>();\n    \n    public static void causeLeak() {\n        while (true) {\n            byte[] data = new byte[1024 * 1024];  // 1MB\n            list.add(data);  // Hech qachon o'chirilmaydi!\n            // Oxir-oqibat OutOfMemoryError\n        }\n    }\n}\n\n// Yaxshi practice\npublic static void processData() {\n    List<String> data = new ArrayList<>();\n    // Data dan foydalanish\n    data.clear();  // Ishlatib bo'lgach tozalash\n    data = null;   // Reference ni yo'qotish\n    // Garbage Collector tozalaydi\n}"
  },

  // Java Fundamentals
  {
    id: 16,
    category: "Java Fundamentals",
    question: "JDK, JRE va JVM o'rtasidagi farq nima?",
    answer: "JDK (Java Development Kit) - bu Java dasturlarini ishlab chiqish uchun to'liq paket bo'lib, u kompilyator (javac), debugger va boshqa development tool larni o'z ichiga oladi. JRE (Java Runtime Environment) - bu Java dasturlarini ishga tushirish uchun muhit bo'lib, faqat runtime library va JVM ni o'z ichiga oladi. JVM (Java Virtual Machine) - bu Java bytecode ni ishga tushiradigan virtual mashina.",
    example: "JDK = JRE + Development Tools\nJRE = JVM + Library Classes\nJVM = Bytecode ni ishga tushiradi"
  },
  {
    id: 2,
    category: "Java Fundamentals",
    question: "Java da primitive va reference tiplar o'rtasidagi farq nima?",
    answer: "Primitive tiplar (int, long, boolean, char va boshqalar) - bu oddiy qiymatlar bo'lib, stack memory da saqlanadi va to'g'ridan-to'g'ri qiymatni o'zida saqlaydi. Reference tiplar (String, Array, Object va boshqalar) - bu obyektlarga havola bo'lib, heap memory da saqlanadi va stack da faqat obyektning manzili (reference) saqlanadi.",
    example: "int age = 25; // primitive - qiymat stack da\nString name = \"Ali\"; // reference - obyekt heap da, manzil stack da"
  },
  {
    id: 3,
    category: "Java Fundamentals",
    question: "== va equals() metodlari o'rtasidagi farq nima?",
    answer: "== operatori ikkita o'zgaruvchining memory addresslarini (reference) solishtiradi, ya'ni ular bir xil obyektmi yoki yo'qligini tekshiradi. equals() metodi esa obyektlarning kontentini (qiymatlarini) solishtiradi. String va wrapper klasslarda equals() override qilingan.",
    example: "String s1 = new String(\"Java\");\nString s2 = new String(\"Java\");\ns1 == s2; // false (turli obyektlar)\ns1.equals(s2); // true (bir xil qiymat)"
  },
  {
    id: 4,
    category: "Java Fundamentals",
    question: "String, StringBuilder va StringBuffer o'rtasidagi farq nima?",
    answer: "String - immutable (o'zgarmas) klass bo'lib, har safar o'zgarishda yangi obyekt yaratadi. StringBuilder - mutable (o'zgaruvchan) va thread-safe emas, lekin tezkor. StringBuffer - mutable va thread-safe (synchronized), lekin sekinroq. Ko'p string operatsiyalari uchun StringBuilder tavsiya etiladi.",
    example: "String str = \"Java\"; // immutable\nstr = str + \" Programming\"; // yangi obyekt yaratiladi\n\nStringBuilder sb = new StringBuilder(\"Java\");\nsb.append(\" Programming\"); // bir xil obyekt o'zgaradi"
  },
  {
    id: 5,
    category: "Java Fundamentals",
    question: "Java da pass-by-value qanday ishlaydi?",
    answer: "Java da barcha parametrlar pass-by-value orqali uzatiladi. Primitive tiplar uchun qiymatning o'zi copy qilinadi. Reference tiplar uchun esa reference (manzil) copy qilinadi, lekin obyektning o'zi emas. Shuning uchun metod ichida obyektning fieldlarini o'zgartirish mumkin, lekin reference ni o'zgartirish tashqariga ta'sir qilmaydi.",
    example: "void change(int x) { x = 10; } // tashqaridagi o'zgaruvchiga ta'sir qilmaydi\nvoid change(Person p) { p.name = \"Ali\"; } // obyekt o'zgaradi\nvoid change(Person p) { p = new Person(); } // faqat lokal reference o'zgaradi"
  },

  // OOP Prinsiplari
  {
    id: 6,
    category: "OOP",
    question: "OOP ning 4 ta asosiy prinsipi qaysilar?",
    answer: "Encapsulation (Inkapsulyatsiya) - ma'lumotlarni yashirish va faqat kerakli metodlar orqali kirish huquqini berish. Inheritance (Meros olish) - bir klassning xususiyatlarini boshqa klassga o'tkazish. Polymorphism (Polimorfizm) - bir interfeys orqali turli xil implementatsiyalarni ishlatish. Abstraction (Abstraktsiya) - murakkab tizimning faqat kerakli qismlarini ko'rsatish va detaillarni yashirish.",
    example: "// Encapsulation\nprivate String name;\npublic String getName() { return name; }\n\n// Inheritance\nclass Dog extends Animal { }\n\n// Polymorphism\nAnimal a = new Dog();\na.makeSound(); // Dog ning metodi chaqiriladi"
  },
  {
    id: 7,
    category: "OOP",
    question: "Abstract class va Interface o'rtasidagi farq nima?",
    answer: "Abstract class - bu partial implementation bo'lishi mumkin bo'lgan klass bo'lib, constructor, field va concrete metodlarga ega bo'lishi mumkin. Bitta abstract classdan extends qilish mumkin. Interface - bu to'liq abstraction bo'lib, Java 8 dan oldin faqat abstract metodlar bo'lgan. Default va static metodlar Java 8 dan qo'shildi. Ko'p interfacelarni implement qilish mumkin.",
    example: "// Abstract class\nabstract class Animal {\n    String name;\n    abstract void makeSound();\n    void sleep() { System.out.println(\"sleeping\"); }\n}\n\n// Interface\ninterface Flyable {\n    void fly();\n    default void land() { System.out.println(\"landing\"); }\n}"
  },
  {
    id: 8,
    category: "OOP",
    question: "Method Overloading va Method Overriding farqi nima?",
    answer: "Method Overloading (Compile-time polymorphism) - bir xil nomli metodlarni turli xil parametrlar bilan yaratish. Bir klass ichida bo'ladi. Method Overriding (Runtime polymorphism) - parent klassdagi metodning funksionalligini child klassda qayta yozish. Bir xil method signature bo'lishi kerak.",
    example: "// Overloading\nclass Calculator {\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n}\n\n// Overriding\nclass Animal {\n    void makeSound() { System.out.println(\"Some sound\"); }\n}\nclass Dog extends Animal {\n    @Override\n    void makeSound() { System.out.println(\"Bark\"); }\n}"
  },
  {
    id: 9,
    category: "OOP",
    question: "final, finally va finalize o'rtasidagi farq nima?",
    answer: "final - bu keyword bo'lib, variable, method yoki classni o'zgarmas qilish uchun ishlatiladi. final variable qayta assign qilinmaydi, final method override qilinmaydi, final class extend qilinmaydi. finally - try-catch bloklaridan keyin har doim bajariladigan kod bloki. finalize() - bu Object klassidagi metod bo'lib, garbage collector obyektni o'chirishdan oldin chaqiradi (deprecated Java 9 dan).",
    example: "final int MAX = 100; // o'zgarmas o'zgaruvchi\n\ntry { } catch(Exception e) { } finally { /* har doim bajariladi */ }\n\nprotected void finalize() { /* cleanup kodi */ }"
  },
  {
    id: 10,
    category: "OOP",
    question: "Java da Constructor nima va qanday ishlaydi?",
    answer: "Constructor - bu klassning obyekti yaratilganda avtomatik chaqiriladigan maxsus metod. Nom klassdagi nom bilan bir xil va return type yo'q. Default constructor kompilyator tomonidan avtomatik yaratiladi (agar o'zingiz yaratmasangiz). Constructorlar overload qilinishi mumkin. this() va super() orqali boshqa constructorlarni chaqirish mumkin.",
    example: "class Person {\n    String name;\n    int age;\n    \n    // Default constructor\n    Person() { }\n    \n    // Parameterized constructor\n    Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    // Constructor chaining\n    Person(String name) {\n        this(name, 0); // boshqa constructorni chaqiradi\n    }\n}"
  },

  // Collections Framework
  {
    id: 11,
    category: "Collections",
    question: "ArrayList va LinkedList o'rtasidagi farq nima?",
    answer: "ArrayList - dynamic array asosida qurilgan bo'lib, index bo'yicha elementlarga tez kirish imkonini beradi (O(1)). Lekin o'rtaga element qo'shish/o'chirish sekin (O(n)). LinkedList - doubly-linked list asosida qurilgan, element qo'shish/o'chirish tez (O(1)), lekin index bo'yicha kirish sekin (O(n)). Ko'p o'qish uchun ArrayList, ko'p qo'shish/o'chirish uchun LinkedList yaxshi.",
    example: "// ArrayList\nList<String> arrayList = new ArrayList<>();\narrayList.get(0); // O(1) - tez\narrayList.add(0, \"item\"); // O(n) - sekin\n\n// LinkedList\nList<String> linkedList = new LinkedList<>();\nlinkedList.get(0); // O(n) - sekin\nlinkedList.add(0, \"item\"); // O(1) - tez"
  },
  {
    id: 12,
    category: "Collections",
    question: "HashMap qanday ishlaydi va qachon ishlatiladi?",
    answer: "HashMap - bu key-value juftliklarini saqlaydigan data structure bo'lib, hashing mexanizmi yordamida ishlaydi. HashMap key ning hashCode() metodini chaqiradi va qaysi bucket ga qo'yishni aniqlaydi. Collision holatlarda linked list (yoki tree Java 8 dan) ishlatiladi. O(1) average time complexity ga ega. Thread-safe emas.",
    example: "Map<String, Integer> map = new HashMap<>();\nmap.put(\"Ali\", 25); // key-value qo'shish\nmap.get(\"Ali\"); // 25 qaytaradi\nmap.containsKey(\"Ali\"); // true\nmap.remove(\"Ali\"); // o'chirish\n\n// Iteration\nfor (Map.Entry<String, Integer> entry : map.entrySet()) {\n    System.out.println(entry.getKey() + \": \" + entry.getValue());\n}"
  },
  {
    id: 13,
    category: "Collections",
    question: "HashSet va TreeSet o'rtasidagi farq nima?",
    answer: "HashSet - HashMap asosida qurilgan bo'lib, elementlarni tartibsiz saqlaydi va null qabul qiladi. O(1) time complexity. TreeSet - Red-Black tree asosida qurilgan bo'lib, elementlarni natural order yoki custom Comparator bo'yicha tartiblangan holda saqlaydi. Null qabul qilmaydi. O(log n) time complexity. Tartiblangan to'plam kerak bo'lsa TreeSet, aks holda HashSet ishlatiladi.",
    example: "// HashSet\nSet<String> hashSet = new HashSet<>();\nhashSet.add(\"Java\");\nhashSet.add(\"Python\");\nhashSet.add(\"C++\"); // tartibsiz\n\n// TreeSet\nSet<String> treeSet = new TreeSet<>();\ntreeSet.add(\"Java\");\ntreeSet.add(\"Python\");\ntreeSet.add(\"C++\"); // alfabetik tartiblangan"
  },
  {
    id: 14,
    category: "Collections",
    question: "Iterator va ListIterator farqi nima?",
    answer: "Iterator - barcha Collection larni iterate qilish uchun ishlatiladi. Faqat forward direction da harakat qiladi va remove() metodini qo'llab-quvvatlaydi. ListIterator - faqat List lar uchun ishlatiladi va ikkala yo'nalishda harakat qila oladi (hasNext/hasPrevious). Element qo'shish (add) va o'zgartirish (set) metodlarini ham qo'llab-quvvatlaydi.",
    example: "// Iterator\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    String item = iterator.next();\n    iterator.remove(); // o'chirish mumkin\n}\n\n// ListIterator\nListIterator<String> listIterator = list.listIterator();\nwhile (listIterator.hasNext()) {\n    String item = listIterator.next();\n    listIterator.set(\"New\"); // o'zgartirish\n    listIterator.add(\"Item\"); // qo'shish\n}\nwhile (listIterator.hasPrevious()) {\n    String item = listIterator.previous(); // orqaga\n}"
  },
  {
    id: 15,
    category: "Collections",
    question: "Comparable va Comparator interfeyslari farqi nima?",
    answer: "Comparable - klassning natural ordering ni belgilash uchun ishlatiladi va compareTo() metodini implement qiladi. Klassning ichida implement qilinadi. Bitta tartiblash mantiqiga ega. Comparator - tashqi tartiblash mantiqini yaratish uchun ishlatiladi va compare() metodini implement qiladi. Alohida klass sifatida yaratiladi. Ko'p turli tartiblash mantiqlarini yaratish mumkin.",
    example: "// Comparable\nclass Student implements Comparable<Student> {\n    String name;\n    int age;\n    \n    public int compareTo(Student other) {\n        return this.age - other.age; // yosh bo'yicha\n    }\n}\n\n// Comparator\nComparator<Student> nameComparator = new Comparator<Student>() {\n    public int compare(Student s1, Student s2) {\n        return s1.name.compareTo(s2.name); // ism bo'yicha\n    }\n};\n\nCollections.sort(students); // Comparable\nCollections.sort(students, nameComparator); // Comparator"
  },

  // Multithreading & Concurrency (Junior)
  {
    id: 16,
    category: "Multithreading (Junior)",
    question: "Thread yaratishning qanday usullari mavjud?",
    answer: "Java da threadlarni yaratishning 3 ta asosiy usuli mavjud: 1) Thread klassini extend qilish va run() metodini override qilish. 2) Runnable interfeysi ni implement qilish (ko'proq tavsiya etiladi chunki Java multiple inheritance ni qo'llab-quvvatlamaydi). 3) Callable interfeysi va ExecutorService ishlatish (natija qaytarish imkoniyati bilan).",
    example: "// 1. Thread klassini extend qilish\nclass MyThread extends Thread {\n    public void run() { System.out.println(\"Running\"); }\n}\nnew MyThread().start();\n\n// 2. Runnable interfeysi\nclass MyRunnable implements Runnable {\n    public void run() { System.out.println(\"Running\"); }\n}\nnew Thread(new MyRunnable()).start();\n\n// 3. Lambda bilan\nnew Thread(() -> System.out.println(\"Running\")).start();"
  },
  {
    id: 17,
    category: "Multithreading (Junior)",
    question: "synchronized keyword qachon va qanday ishlatiladi?",
    answer: "synchronized - thread-safety ni ta'minlash uchun ishlatiladi va bir vaqtning o'zida faqat bitta thread critical section ga kirishini ta'minlaydi. Method yoki kod blokida ishlatilish mumkin. synchronized method butun metodga lock qo'yadi. synchronized block faqat kerakli qismga lock qo'yadi va ancha moslashuvchan. Lock obyekti sifatida this, class yoki boshqa obyekt ishlatilishi mumkin.",
    example: "// Synchronized method\npublic synchronized void increment() {\n    count++;\n}\n\n// Synchronized block\npublic void increment() {\n    synchronized(this) {\n        count++;\n    }\n}\n\n// Static synchronized\npublic static synchronized void method() {\n    // Class-level lock\n}\n\n// Custom lock object\nprivate final Object lock = new Object();\npublic void increment() {\n    synchronized(lock) {\n        count++;\n    }\n}"
  },
  {
    id: 18,
    category: "Multithreading (Junior)",
    question: "wait(), notify() va notifyAll() metodlari qanday ishlaydi?",
    answer: "Bu metodlar Object klassida aniqlangan va thread synchronization uchun ishlatiladi. wait() - joriy threadni kutish holatiga o'tkazadi va lock ni bo'shatadi. notify() - kutayotgan threadlardan birini uyg'otadi. notifyAll() - barcha kutayotgan threadlarni uyg'otadi. Bu metodlar faqat synchronized blok yoki metod ichida chaqirilishi kerak, aks holda IllegalMonitorStateException yuzaga keladi.",
    example: "class SharedResource {\n    private boolean available = false;\n    \n    public synchronized void produce() {\n        while (available) {\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        // produce item\n        available = true;\n        notify(); // consumerni uyg'ot\n    }\n    \n    public synchronized void consume() {\n        while (!available) {\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        // consume item\n        available = false;\n        notify(); // producerni uyg'ot\n    }\n}"
  },
  {
    id: 19,
    category: "Multithreading (Junior)",
    question: "Deadlock nima va qanday oldini olish mumkin?",
    answer: "Deadlock - bu ikki yoki undan ortiq threadlar bir-birlarini kutib qolgan holat bo'lib, hech biri davom eta olmaydi. 4 ta shart bajarilganda yuzaga keladi: Mutual Exclusion, Hold and Wait, No Preemption, Circular Wait. Oldini olish usullari: 1) Lock ordering - barcha threadlar bir xil tartibda locklar olishi kerak. 2) Lock timeout ishlatish. 3) Deadlock detection va recovery. 4) tryLock() ishlatish.",
    example: "// Deadlock holati\nclass Account {\n    synchronized void transfer(Account to, int amount) {\n        // this ga lock\n        synchronized(to) { // to ga lock - DEADLOCK!\n            this.balance -= amount;\n            to.balance += amount;\n        }\n    }\n}\n\n// Yechim: Lock ordering\nvoid transfer(Account to, int amount) {\n    Account first = this.id < to.id ? this : to;\n    Account second = this.id < to.id ? to : this;\n    synchronized(first) {\n        synchronized(second) {\n            this.balance -= amount;\n            to.balance += amount;\n        }\n    }\n}"
  },
  {
    id: 20,
    category: "Multithreading (Junior)",
    question: "Executor Framework nima va nima uchun ishlatiladi?",
    answer: "Executor Framework - bu thread pool larni boshqarish uchun high-level API. Thread yaratish va boshqarishni soddalashtradi. Executors utility class turli xil thread poollar yaratishni ta'minlaydi: newFixedThreadPool, newCachedThreadPool, newSingleThreadExecutor, newScheduledThreadPool. ExecutorService interfeysi task submit qilish, shutdown qilish va boshqa operatsiyalarni boshqaradi.",
    example: "// Fixed thread pool\nExecutorService executor = Executors.newFixedThreadPool(5);\n\n// Task submit qilish\nexecutor.submit(() -> {\n    System.out.println(\"Task running\");\n});\n\n// Future bilan natija olish\nFuture<Integer> future = executor.submit(() -> {\n    return 42;\n});\nInteger result = future.get();\n\n// Shutdown\nexecutor.shutdown();\nexecutor.awaitTermination(1, TimeUnit.MINUTES);"
  },
  {
    id: 86,
    category: "Multithreading (Junior)",
    question: "Thread Safety nima va Race Condition qanday yuzaga keladi?",
    answer: "Thread Safety - bir nechta threadlar bir vaqtda ma'lumotga kirganida ham to'g'ri ishlashni ta'minlash. Race Condition - ikki yoki ko'p threadlar bir vaqtda shared data ga kirganida natija threadlarning bajarilish tartibiga bog'liq bo'ladi. Bu unpredictable va incorrect natijalarga olib keladi. Thread-safe kod yaratish uchun: 1) synchronized, 2) volatile, 3) Atomic classes, 4) Lock lar, 5) Thread-safe collections, 6) Immutable objects ishlatiladi.",
    example: "// Race Condition misoli\nclass Counter {\n    private int count = 0;\n    \n    // Thread-safe emas!\n    public void increment() {\n        count++; // 3 ta operation: read, increment, write\n    }\n    \n    public int getCount() {\n        return count;\n    }\n}\n\n// 2 ta thread bir vaqtda increment() ni chaqirsa:\n// Thread 1: count ni o'qiydi (0)\n// Thread 2: count ni o'qiydi (0)\n// Thread 1: 0 + 1 = 1 yozadi\n// Thread 2: 0 + 1 = 1 yozadi\n// Natija: 1 (kutilgan: 2) - Race Condition!\n\n// Yechim 1: synchronized\nclass ThreadSafeCounter {\n    private int count = 0;\n    \n    public synchronized void increment() {\n        count++;\n    }\n}\n\n// Yechim 2: AtomicInteger\nclass AtomicCounter {\n    private AtomicInteger count = new AtomicInteger(0);\n    \n    public void increment() {\n        count.incrementAndGet();\n    }\n}\n\n// Test\nCounter counter = new Counter();\nExecutorService executor = Executors.newFixedThreadPool(10);\nfor (int i = 0; i < 1000; i++) {\n    executor.submit(() -> counter.increment());\n}\nexecutor.shutdown();\nexecutor.awaitTermination(1, TimeUnit.SECONDS);\nSystem.out.println(counter.getCount()); // 1000 dan kam bo'lishi mumkin!"
  },
  {
    id: 87,
    category: "Multithreading (Junior)",
    question: "volatile keyword nima va qachon ishlatiladi?",
    answer: "volatile - o'zgaruvchi har doim main memory dan o'qilishi va main memory ga yozilishini ta'minlaydi. Thread-local cache dan emas. Visibility problem ni hal qiladi - bir thread o'zgaruvchini o'zgartirsa, boshqa threadlar darhol ko'radi. Lekin atomicity ni ta'minlamaydi - compound operations (++, --, +=) uchun yetarli emas. Qachon ishlatiladi: 1) Flag variable (boolean). 2) Double-checked locking. 3) Status flag. synchronized dan yengilroq, lekin kamroq ta'minot beradi.",
    example: "// Visibility problem\nclass SharedFlag {\n    private boolean flag = false; // volatile yo'q\n    \n    public void setFlag() {\n        flag = true; // Thread 1\n    }\n    \n    public void checkFlag() {\n        while (!flag) { // Thread 2 - infinite loop!\n            // Thread 2 o'z cache dan o'qiydi, main memory dan emas\n        }\n        System.out.println(\"Flag is true\");\n    }\n}\n\n// Yechim: volatile\nclass VolatileFlag {\n    private volatile boolean flag = false;\n    \n    public void setFlag() {\n        flag = true; // Main memory ga yoziladi\n    }\n    \n    public void checkFlag() {\n        while (!flag) { // Main memory dan o'qiladi\n        }\n        System.out.println(\"Flag is true\");\n    }\n}\n\n// volatile atomicity ni ta'minlamaydi\nclass VolatileCounter {\n    private volatile int count = 0;\n    \n    public void increment() {\n        count++; // Thread-safe EMAS! (read + increment + write)\n    }\n}\n\n// To'g'ri yechim: synchronized yoki AtomicInteger\nclass AtomicCounter {\n    private AtomicInteger count = new AtomicInteger(0);\n    \n    public void increment() {\n        count.incrementAndGet(); // Atomic operation\n    }\n}\n\n// volatile uchun ideal case: status flag\nclass Worker {\n    private volatile boolean running = true;\n    \n    public void stop() {\n        running = false;\n    }\n    \n    public void run() {\n        while (running) {\n            // work\n        }\n    }\n}"
  },

  // Concurrency (Middle)
  {
    id: 88,
    category: "Concurrency (Middle)",
    question: "Atomic classes (AtomicInteger, AtomicLong) qanday ishlaydi?",
    answer: "Atomic classes - lock-free thread-safe operatsiyalarni ta'minlaydi. Compare-And-Swap (CAS) algoritmi asosida qurilgan. synchronized dan tezroq, chunki lock yo'q. java.util.concurrent.atomic package da joylashgan. AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference va boshqalar mavjud. incrementAndGet(), decrementAndGet(), getAndIncrement(), compareAndSet(), updateAndGet() kabi metodlar bor. Counter, sequence generator uchun ideal.",
    example: "// AtomicInteger misoli\nclass AtomicCounter {\n    private AtomicInteger count = new AtomicInteger(0);\n    \n    public void increment() {\n        count.incrementAndGet(); // Atomic: count++ ga teng\n    }\n    \n    public void decrement() {\n        count.decrementAndGet();\n    }\n    \n    public int get() {\n        return count.get();\n    }\n    \n    public void addAndGet(int delta) {\n        count.addAndGet(delta);\n    }\n    \n    // Compare and Set\n    public boolean compareAndSet(int expect, int update) {\n        return count.compareAndSet(expect, update);\n    }\n}\n\n// AtomicReference\nclass AtomicUser {\n    private AtomicReference<User> currentUser = new AtomicReference<>();\n    \n    public void setUser(User user) {\n        currentUser.set(user);\n    }\n    \n    public User getUser() {\n        return currentUser.get();\n    }\n    \n    // Update with function\n    public void updateAge(int newAge) {\n        currentUser.updateAndGet(user -> {\n            user.setAge(newAge);\n            return user;\n        });\n    }\n}\n\n// Performance test\nclass PerformanceTest {\n    private int synchronizedCount = 0;\n    private AtomicInteger atomicCount = new AtomicInteger(0);\n    \n    public synchronized void incrementSync() {\n        synchronizedCount++;\n    }\n    \n    public void incrementAtomic() {\n        atomicCount.incrementAndGet();\n    }\n}\n// Natija: AtomicInteger tezroq (low contention da)\n\n// AtomicLong - ID generator\nclass IdGenerator {\n    private static final AtomicLong nextId = new AtomicLong(0);\n    \n    public static long generateId() {\n        return nextId.incrementAndGet();\n    }\n}\n\n// LongAdder - high contention uchun\nclass HighPerformanceCounter {\n    private LongAdder count = new LongAdder();\n    \n    public void increment() {\n        count.increment(); // AtomicLong dan tezroq\n    }\n    \n    public long sum() {\n        return count.sum();\n    }\n}"
  },
  {
    id: 89,
    category: "Concurrency (Middle)",
    question: "ReentrantLock va synchronized farqi nima?",
    answer: "ReentrantLock - java.util.concurrent.locks package dagi Lock interfeysi implementatsiyasi. synchronized dan ko'proq flexibility beradi. Asosiy farqlar: 1) tryLock() - lock olishga urinish, kutmaslik. 2) lockInterruptibly() - interrupt qilish mumkin. 3) Fair lock - FIFO tartibida. 4) Multiple conditions. 5) try-finally bilan unlock majburiy. ReentrantLock qo'lda boshqariladi, synchronized avtomatik. ReadWriteLock bilan ham ishlaydi. synchronized oddiyroq, lekin kamroq flexible.",
    example: "// synchronized\nclass SynchronizedCounter {\n    private int count = 0;\n    \n    public synchronized void increment() {\n        count++;\n    } // Lock avtomatik ochiladi\n}\n\n// ReentrantLock\nclass ReentrantLockCounter {\n    private int count = 0;\n    private final ReentrantLock lock = new ReentrantLock();\n    \n    public void increment() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // Majburiy!\n        }\n    }\n}\n\n// tryLock() - non-blocking\nclass BankAccount {\n    private double balance = 0;\n    private final ReentrantLock lock = new ReentrantLock();\n    \n    public boolean withdraw(double amount) {\n        if (lock.tryLock()) { // Lock olishga harakat\n            try {\n                if (balance >= amount) {\n                    balance -= amount;\n                    return true;\n                }\n                return false;\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            System.out.println(\"Could not acquire lock\");\n            return false;\n        }\n    }\n    \n    // tryLock with timeout\n    public boolean withdrawWithTimeout(double amount) throws InterruptedException {\n        if (lock.tryLock(1, TimeUnit.SECONDS)) {\n            try {\n                balance -= amount;\n                return true;\n            } finally {\n                lock.unlock();\n            }\n        }\n        return false;\n    }\n}\n\n// Fair Lock\nclass FairLockExample {\n    private final ReentrantLock fairLock = new ReentrantLock(true); // Fair\n    \n    public void doWork() {\n        fairLock.lock();\n        try {\n            // Thread FIFO tartibida lock oladi\n            System.out.println(Thread.currentThread().getName() + \" working\");\n        } finally {\n            fairLock.unlock();\n        }\n    }\n}\n\n// Condition - wait/notify alternative\nclass BoundedBuffer {\n    private final Lock lock = new ReentrantLock();\n    private final Condition notFull = lock.newCondition();\n    private final Condition notEmpty = lock.newCondition();\n    private final Object[] items = new Object[100];\n    private int count, putIndex, takeIndex;\n    \n    public void put(Object x) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length) {\n                notFull.await(); // wait() alternative\n            }\n            items[putIndex] = x;\n            if (++putIndex == items.length) putIndex = 0;\n            ++count;\n            notEmpty.signal(); // notify() alternative\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public Object take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0) {\n                notEmpty.await();\n            }\n            Object x = items[takeIndex];\n            if (++takeIndex == items.length) takeIndex = 0;\n            --count;\n            notFull.signal();\n            return x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}"
  },
  {
    id: 90,
    category: "Concurrency (Middle)",
    question: "ReadWriteLock nima va qachon ishlatiladi?",
    answer: "ReadWriteLock - read va write operatsiyalari uchun alohida locklar. Ko'p threadlar bir vaqtda o'qishi mumkin (read lock), lekin faqat bitta thread yoza oladi (write lock). Write lock exclusive, read lock shared. Read-heavy applicationlar uchun performance yaxshilaydi. ReentrantReadWriteLock - asosiy implementatsiya. Downgrade (write -> read) mumkin, upgrade (read -> write) to'g'ridan-to'g'ri emas. Cache, configuration, read-mostly data structures uchun ideal.",
    example: "// ReadWriteLock misoli\nclass CachedData {\n    private final Map<String, String> cache = new HashMap<>();\n    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n    private final Lock readLock = rwLock.readLock();\n    private final Lock writeLock = rwLock.writeLock();\n    \n    // Read operation - ko'p threadlar parallel\n    public String get(String key) {\n        readLock.lock();\n        try {\n            return cache.get(key);\n        } finally {\n            readLock.unlock();\n        }\n    }\n    \n    // Write operation - faqat bitta thread\n    public void put(String key, String value) {\n        writeLock.lock();\n        try {\n            cache.put(key, value);\n        } finally {\n            writeLock.unlock();\n        }\n    }\n    \n    // Check and update pattern\n    public String getOrCompute(String key) {\n        // Avval read lock bilan tekshirish\n        readLock.lock();\n        String value = cache.get(key);\n        readLock.unlock();\n        \n        if (value == null) {\n            // Agar yo'q bo'lsa, write lock bilan qo'shish\n            writeLock.lock();\n            try {\n                // Double-check\n                value = cache.get(key);\n                if (value == null) {\n                    value = computeValue(key);\n                    cache.put(key, value);\n                }\n            } finally {\n                writeLock.unlock();\n            }\n        }\n        return value;\n    }\n    \n    private String computeValue(String key) {\n        // Expensive computation\n        return \"computed_\" + key;\n    }\n}\n\n// Lock downgrade\nclass DataHolder {\n    private String data;\n    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n    \n    public void updateData(String newData) {\n        rwLock.writeLock().lock();\n        try {\n            data = newData;\n            \n            // Downgrade: write lock -> read lock\n            rwLock.readLock().lock();\n        } finally {\n            rwLock.writeLock().unlock();\n        }\n        \n        try {\n            // Endi read lock bilan ishlash\n            processData(data);\n        } finally {\n            rwLock.readLock().unlock();\n        }\n    }\n    \n    private void processData(String data) {\n        // Process logic\n    }\n}\n\n// Performance comparison\nclass PerformanceTest {\n    private int value = 0;\n    private final ReentrantLock lock = new ReentrantLock();\n    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n    \n    // synchronized: har safar lock\n    public synchronized int getSynchronized() {\n        return value;\n    }\n    \n    // ReentrantLock: har safar lock\n    public int getLock() {\n        lock.lock();\n        try {\n            return value;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    // ReadWriteLock: parallel reads\n    public int getReadWriteLock() {\n        rwLock.readLock().lock();\n        try {\n            return value;\n        } finally {\n            rwLock.readLock().unlock();\n        }\n    }\n}\n// Read-heavy workload: ReadWriteLock >> Lock >> synchronized"
  },
  {
    id: 91,
    category: "Concurrency (Middle)",
    question: "CountDownLatch va CyclicBarrier farqi nima?",
    answer: "CountDownLatch - bir yoki ko'p threadlarni boshqa threadlar vazifalarini tugatguncha kutishini ta'minlaydi. Count 0 ga yetguncha await() blok qiladi. countDown() count ni kamaytiradi. Bir martalik - reuse qilib bo'lmaydi. CyclicBarrier - bir nechta threadlarni bir nuqtada kutishini ta'minlaydi. Barcha threadlar barrier ga yetganida hammasi davom etadi. Reusable - reset() qilish mumkin. Barrier action - barcha threadlar yetganda execute qilinadigan task.",
    example: "// CountDownLatch - bitta martalik\nclass CountDownLatchExample {\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(3);\n        \n        // Worker threadlar\n        for (int i = 0; i < 3; i++) {\n            new Thread(() -> {\n                System.out.println(Thread.currentThread().getName() + \" working...\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {}\n                System.out.println(Thread.currentThread().getName() + \" done\");\n                latch.countDown(); // Count ni kamaytirish\n            }).start();\n        }\n        \n        // Main thread kutadi\n        System.out.println(\"Waiting for workers...\");\n        latch.await(); // 0 ga yetguncha kutadi\n        System.out.println(\"All workers done!\");\n    }\n}\n\n// CyclicBarrier - reusable\nclass CyclicBarrierExample {\n    public static void main(String[] args) {\n        CyclicBarrier barrier = new CyclicBarrier(3, () -> {\n            // Barcha threadlar barrier ga yetganda\n            System.out.println(\"All threads reached barrier!\");\n        });\n        \n        for (int i = 0; i < 3; i++) {\n            new Thread(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" phase 1\");\n                    Thread.sleep(1000);\n                    barrier.await(); // Barrier da kutish\n                    \n                    System.out.println(Thread.currentThread().getName() + \" phase 2\");\n                    Thread.sleep(1000);\n                    barrier.await(); // Qayta ishlatish!\n                    \n                    System.out.println(Thread.currentThread().getName() + \" done\");\n                } catch (Exception e) {}\n            }).start();\n        }\n    }\n}\n\n// CountDownLatch - Service startup\nclass ApplicationStartup {\n    private final CountDownLatch latch = new CountDownLatch(3);\n    \n    public void startApplication() throws InterruptedException {\n        // Start services\n        new Thread(() -> {\n            System.out.println(\"Starting Database...\");\n            // Init DB\n            latch.countDown();\n        }).start();\n        \n        new Thread(() -> {\n            System.out.println(\"Starting Cache...\");\n            // Init Cache\n            latch.countDown();\n        }).start();\n        \n        new Thread(() -> {\n            System.out.println(\"Starting Message Queue...\");\n            // Init MQ\n            latch.countDown();\n        }).start();\n        \n        // Wait for all services\n        latch.await();\n        System.out.println(\"Application started!\");\n    }\n}\n\n// CyclicBarrier - Parallel computation\nclass ParallelMatrixMultiplication {\n    private final int[][] matrix;\n    private final int threads = 4;\n    private final CyclicBarrier barrier;\n    \n    public ParallelMatrixMultiplication(int[][] matrix) {\n        this.matrix = matrix;\n        this.barrier = new CyclicBarrier(threads, () -> {\n            System.out.println(\"Phase completed!\");\n        });\n    }\n    \n    public void compute() {\n        for (int i = 0; i < threads; i++) {\n            final int threadId = i;\n            new Thread(() -> {\n                try {\n                    // Phase 1: Compute\n                    computePartition(threadId);\n                    barrier.await();\n                    \n                    // Phase 2: Merge\n                    mergeResults(threadId);\n                    barrier.await();\n                } catch (Exception e) {}\n            }).start();\n        }\n    }\n    \n    private void computePartition(int id) { }\n    private void mergeResults(int id) { }\n}"
  },
  {
    id: 92,
    category: "Concurrency (Middle)",
    question: "Semaphore nima va qanday ishlatiladi?",
    answer: "Semaphore - ma'lum miqdordagi threadlarga resursga kirish huquqini beradi. Permits (ruxsatnomalar) soni bilan ishlaydi. acquire() - permit olish (kutadi agar yo'q bo'lsa). release() - permit qaytarish. Binary semaphore (1 permit) - mutex ga o'xshash. Counting semaphore (N permits) - connection pool, thread pool kabi cheklangan resurslar uchun. Fair/unfair mode mavjud. tryAcquire() - non-blocking. Resource limiting, rate limiting uchun ishlatiladi.",
    example: "// Basic Semaphore\nclass SemaphoreExample {\n    public static void main(String[] args) {\n        Semaphore semaphore = new Semaphore(3); // 3 ta permit\n        \n        for (int i = 0; i < 10; i++) {\n            new Thread(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" waiting...\");\n                    semaphore.acquire(); // Permit olish\n                    \n                    System.out.println(Thread.currentThread().getName() + \" acquired permit\");\n                    Thread.sleep(2000); // Work simulation\n                    \n                    System.out.println(Thread.currentThread().getName() + \" releasing permit\");\n                } catch (InterruptedException e) {\n                } finally {\n                    semaphore.release(); // Permit qaytarish\n                }\n            }).start();\n        }\n    }\n}\n\n// Connection Pool\nclass ConnectionPool {\n    private final Semaphore semaphore;\n    private final List<Connection> connections;\n    \n    public ConnectionPool(int maxConnections) {\n        this.semaphore = new Semaphore(maxConnections);\n        this.connections = new ArrayList<>();\n        \n        for (int i = 0; i < maxConnections; i++) {\n            connections.add(new Connection(i));\n        }\n    }\n    \n    public Connection getConnection() throws InterruptedException {\n        semaphore.acquire();\n        return getNextAvailableConnection();\n    }\n    \n    public void releaseConnection(Connection connection) {\n        returnConnection(connection);\n        semaphore.release();\n    }\n    \n    // Non-blocking\n    public Connection tryGetConnection() {\n        if (semaphore.tryAcquire()) {\n            return getNextAvailableConnection();\n        }\n        return null; // No connection available\n    }\n    \n    private synchronized Connection getNextAvailableConnection() {\n        return connections.remove(0);\n    }\n    \n    private synchronized void returnConnection(Connection conn) {\n        connections.add(conn);\n    }\n}\n\n// Rate Limiter\nclass RateLimiter {\n    private final Semaphore semaphore;\n    private final int maxRequests;\n    private final long timeWindow;\n    \n    public RateLimiter(int maxRequests, long timeWindowMs) {\n        this.semaphore = new Semaphore(maxRequests);\n        this.maxRequests = maxRequests;\n        this.timeWindow = timeWindowMs;\n        \n        // Permits ni vaqt bo'yicha qaytarish\n        schedulePermitRefill();\n    }\n    \n    public boolean tryAcquire() {\n        return semaphore.tryAcquire();\n    }\n    \n    private void schedulePermitRefill() {\n        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n        scheduler.scheduleAtFixedRate(() -> {\n            int available = semaphore.availablePermits();\n            if (available < maxRequests) {\n                semaphore.release(maxRequests - available);\n            }\n        }, timeWindow, timeWindow, TimeUnit.MILLISECONDS);\n    }\n}\n\n// Parking Lot\nclass ParkingLot {\n    private final Semaphore spaces;\n    \n    public ParkingLot(int capacity) {\n        this.spaces = new Semaphore(capacity, true); // Fair\n    }\n    \n    public boolean parkCar() {\n        try {\n            if (spaces.tryAcquire(5, TimeUnit.SECONDS)) {\n                System.out.println(\"Car parked. Spaces left: \" + spaces.availablePermits());\n                return true;\n            } else {\n                System.out.println(\"No parking space available\");\n                return false;\n            }\n        } catch (InterruptedException e) {\n            return false;\n        }\n    }\n    \n    public void leaveCar() {\n        spaces.release();\n        System.out.println(\"Car left. Spaces available: \" + spaces.availablePermits());\n    }\n}"
  },
  {
    id: 93,
    category: "Concurrency (Middle)",
    question: "ThreadLocal nima va qachon ishlatiladi?",
    answer: "ThreadLocal - har bir thread uchun alohida o'zgaruvchi nusxasi. Threadlar o'rtasida shared emas, har biri o'z qiymatiga ega. Thread-safe bo'lmasdan shared state dan qochish. Web applicationlarda user context, transaction, database connection saqlash uchun. Formatting objects (SimpleDateFormat) uchun. initialValue() bilan default qiymat berish. remove() chaqirish majburiy - memory leak oldini olish uchun. InheritableThreadLocal - child threadlarga o'tkazish.",
    example: "// Basic ThreadLocal\nclass ThreadLocalExample {\n    private static ThreadLocal<Integer> threadLocal = new ThreadLocal<>();\n    \n    public static void main(String[] args) {\n        // Thread 1\n        new Thread(() -> {\n            threadLocal.set(1);\n            System.out.println(\"Thread 1: \" + threadLocal.get());\n            threadLocal.remove(); // Memory leak oldini olish\n        }).start();\n        \n        // Thread 2\n        new Thread(() -> {\n            threadLocal.set(2);\n            System.out.println(\"Thread 2: \" + threadLocal.get());\n            threadLocal.remove();\n        }).start();\n    }\n}\n\n// SimpleDateFormat - thread-safe emas!\nclass DateFormatter {\n    // Yomon: shared SimpleDateFormat\n    private static final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n    \n    public String format(Date date) {\n        return sdf.format(date); // Race condition!\n    }\n    \n    // Yaxshi: ThreadLocal\n    private static final ThreadLocal<SimpleDateFormat> dateFormatter = \n        ThreadLocal.withInitial(() -> new SimpleDateFormat(\"yyyy-MM-dd\"));\n    \n    public String formatSafe(Date date) {\n        return dateFormatter.get().format(date); // Thread-safe\n    }\n}\n\n// User Context\nclass UserContext {\n    private static final ThreadLocal<User> currentUser = new ThreadLocal<>();\n    \n    public static void setUser(User user) {\n        currentUser.set(user);\n    }\n    \n    public static User getUser() {\n        return currentUser.get();\n    }\n    \n    public static void clear() {\n        currentUser.remove(); // MAJBURIY!\n    }\n}\n\n// Web application example\nclass RequestFilter {\n    public void doFilter(HttpServletRequest request) {\n        try {\n            // Set user context\n            User user = authenticate(request);\n            UserContext.setUser(user);\n            \n            // Process request\n            processRequest();\n        } finally {\n            // Clean up - memory leak oldini olish\n            UserContext.clear();\n        }\n    }\n    \n    private User authenticate(HttpServletRequest request) {\n        return new User();\n    }\n    \n    private void processRequest() {\n        // Istalgan joyda user context ga kirish\n        User user = UserContext.getUser();\n        System.out.println(\"Processing for user: \" + user.getName());\n    }\n}\n\n// Transaction Context\nclass TransactionContext {\n    private static final ThreadLocal<Transaction> transaction = new ThreadLocal<>();\n    \n    public static void begin() {\n        transaction.set(new Transaction());\n        transaction.get().begin();\n    }\n    \n    public static void commit() {\n        Transaction tx = transaction.get();\n        if (tx != null) {\n            tx.commit();\n            transaction.remove();\n        }\n    }\n    \n    public static void rollback() {\n        Transaction tx = transaction.get();\n        if (tx != null) {\n            tx.rollback();\n            transaction.remove();\n        }\n    }\n}\n\n// InheritableThreadLocal - child threadlarga o'tadi\nclass InheritableExample {\n    private static InheritableThreadLocal<String> inheritableThreadLocal = \n        new InheritableThreadLocal<>();\n    \n    public static void main(String[] args) {\n        inheritableThreadLocal.set(\"Parent value\");\n        \n        new Thread(() -> {\n            System.out.println(\"Child: \" + inheritableThreadLocal.get());\n            // Output: \"Parent value\" - parent dan meros!\n        }).start();\n    }\n}"
  },

  // Advanced Threading (Senior)
  {
    id: 94,
    category: "Advanced Threading (Senior)",
    question: "CompletableFuture nima va qanday ishlatiladi?",
    answer: "CompletableFuture - asynchronous programming uchun powerful API (Java 8+). Future ni extend qiladi va functional programming features qo'shadi. Non-blocking operations. Method chaining. Multiple CompletableFuture larni combine qilish (thenApply, thenCompose, thenCombine). Exception handling (exceptionally, handle). Parallel execution. Callback mechanisms. supplyAsync, runAsync - asynchronous tasklarni boshlash. join() vs get() - checked exception. CompletionStage interface ni implement qiladi.",
    example: "// Basic CompletableFuture\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n    // Async task\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {}\n    return \"Hello\";\n});\n\nString result = future.join(); // Blocking\nSystem.out.println(result);\n\n// Method chaining - thenApply\nCompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> \"10\")\n    .thenApply(Integer::parseInt)\n    .thenApply(num -> num * 2);\nSystem.out.println(future2.join()); // 20\n\n// Non-blocking callback - thenAccept\nCompletableFuture.supplyAsync(() -> \"Data\")\n    .thenAccept(result -> System.out.println(\"Received: \" + result));\n\n// Combining futures - thenCompose (flatMap)\nCompletableFuture<User> userFuture = CompletableFuture.supplyAsync(() -> getUserId())\n    .thenCompose(id -> CompletableFuture.supplyAsync(() -> getUser(id)));\n\n// Combining futures - thenCombine\nCompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> \"Hello\");\nCompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \"World\");\n\nCompletableFuture<String> combined = future1.thenCombine(future2, \n    (s1, s2) -> s1 + \" \" + s2);\nSystem.out.println(combined.join()); // \"Hello World\"\n\n// Exception handling\nCompletableFuture<String> futureWithError = CompletableFuture.supplyAsync(() -> {\n    if (true) throw new RuntimeException(\"Error!\");\n    return \"Success\";\n}).exceptionally(ex -> {\n    System.out.println(\"Error: \" + ex.getMessage());\n    return \"Default value\";\n});\n\n// handle - both success and error\nCompletableFuture<String> handled = CompletableFuture.supplyAsync(() -> \"Data\")\n    .handle((result, ex) -> {\n        if (ex != null) {\n            return \"Error: \" + ex.getMessage();\n        }\n        return result.toUpperCase();\n    });\n\n// Multiple futures - allOf\nCompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> \"Task1\");\nCompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> \"Task2\");\nCompletableFuture<String> f3 = CompletableFuture.supplyAsync(() -> \"Task3\");\n\nCompletableFuture<Void> allFutures = CompletableFuture.allOf(f1, f2, f3);\nallFutures.join(); // Wait for all\n\nList<String> results = Stream.of(f1, f2, f3)\n    .map(CompletableFuture::join)\n    .collect(Collectors.toList());\n\n// anyOf - first to complete\nCompletableFuture<Object> anyFuture = CompletableFuture.anyOf(f1, f2, f3);\nObject firstResult = anyFuture.join();\n\n// Custom executor\nExecutorService executor = Executors.newFixedThreadPool(10);\nCompletableFuture<String> customFuture = CompletableFuture.supplyAsync(\n    () -> \"Custom thread\", \n    executor\n);\n\n// Real-world example: Parallel API calls\nclass UserService {\n    public CompletableFuture<User> getUserAsync(Long id) {\n        return CompletableFuture.supplyAsync(() -> {\n            // API call\n            return fetchUser(id);\n        });\n    }\n    \n    public CompletableFuture<List<Order>> getOrdersAsync(Long userId) {\n        return CompletableFuture.supplyAsync(() -> {\n            // API call\n            return fetchOrders(userId);\n        });\n    }\n    \n    public CompletableFuture<UserProfile> getUserProfile(Long id) {\n        CompletableFuture<User> userFuture = getUserAsync(id);\n        CompletableFuture<List<Order>> ordersFuture = getOrdersAsync(id);\n        \n        return userFuture.thenCombine(ordersFuture, (user, orders) -> {\n            return new UserProfile(user, orders);\n        });\n    }\n}"
  },
  {
    id: 95,
    category: "Advanced Threading (Senior)",
    question: "Fork/Join Framework qanday ishlaydi?",
    answer: "Fork/Join Framework - parallel processing uchun framework (Java 7+). Work-stealing algorithm asosida. Recursive task larni parallel bajarish. Divide-and-conquer strategiyasi. ForkJoinPool - maxsus thread pool. RecursiveTask<V> - natija qaytaradi. RecursiveAction - natija qaytarmaydi. fork() - subtask ni async bajarish. join() - natijani kutish. compute() - asosiy logika. Parallel streams ham Fork/Join dan foydalanadi. CPU-intensive tasklar uchun ideal.",
    example: "// RecursiveTask - natija qaytaradi\nclass SumTask extends RecursiveTask<Long> {\n    private static final int THRESHOLD = 1000;\n    private final long[] array;\n    private final int start;\n    private final int end;\n    \n    public SumTask(long[] array, int start, int end) {\n        this.array = array;\n        this.start = start;\n        this.end = end;\n    }\n    \n    @Override\n    protected Long compute() {\n        int length = end - start;\n        \n        // Base case: kichik bo'lsa to'g'ridan-to'g'ri hisoblash\n        if (length <= THRESHOLD) {\n            long sum = 0;\n            for (int i = start; i < end; i++) {\n                sum += array[i];\n            }\n            return sum;\n        }\n        \n        // Recursive case: bo'lish\n        int mid = start + length / 2;\n        SumTask leftTask = new SumTask(array, start, mid);\n        SumTask rightTask = new SumTask(array, mid, end);\n        \n        // Fork - parallel bajarish\n        leftTask.fork();\n        long rightResult = rightTask.compute();\n        long leftResult = leftTask.join(); // Kutish\n        \n        return leftResult + rightResult;\n    }\n}\n\n// Ishlatish\nlong[] array = new long[10000];\nfor (int i = 0; i < array.length; i++) {\n    array[i] = i + 1;\n}\n\nForkJoinPool pool = new ForkJoinPool();\nSumTask task = new SumTask(array, 0, array.length);\nlong result = pool.invoke(task);\nSystem.out.println(\"Sum: \" + result);\n\n// RecursiveAction - natija yo'q\nclass SortTask extends RecursiveAction {\n    private static final int THRESHOLD = 100;\n    private final int[] array;\n    private final int start;\n    private final int end;\n    \n    public SortTask(int[] array, int start, int end) {\n        this.array = array;\n        this.start = start;\n        this.end = end;\n    }\n    \n    @Override\n    protected void compute() {\n        if (end - start <= THRESHOLD) {\n            Arrays.sort(array, start, end);\n        } else {\n            int mid = start + (end - start) / 2;\n            SortTask leftTask = new SortTask(array, start, mid);\n            SortTask rightTask = new SortTask(array, mid, end);\n            \n            invokeAll(leftTask, rightTask); // Parallel bajarish\n            merge(start, mid, end);\n        }\n    }\n    \n    private void merge(int start, int mid, int end) {\n        // Merge logic\n    }\n}\n\n// Real-world: Parallel file processing\nclass FileProcessor extends RecursiveAction {\n    private final List<File> files;\n    private static final int THRESHOLD = 10;\n    \n    public FileProcessor(List<File> files) {\n        this.files = files;\n    }\n    \n    @Override\n    protected void compute() {\n        if (files.size() <= THRESHOLD) {\n            // Process files sequentially\n            for (File file : files) {\n                processFile(file);\n            }\n        } else {\n            // Split and process in parallel\n            int mid = files.size() / 2;\n            FileProcessor left = new FileProcessor(files.subList(0, mid));\n            FileProcessor right = new FileProcessor(files.subList(mid, files.size()));\n            \n            invokeAll(left, right);\n        }\n    }\n    \n    private void processFile(File file) {\n        // File processing logic\n    }\n}\n\n// Matrix multiplication\nclass MatrixMultiplication extends RecursiveTask<int[][]> {\n    private final int[][] a;\n    private final int[][] b;\n    private final int startRow;\n    private final int endRow;\n    \n    @Override\n    protected int[][] compute() {\n        // Implementation\n        return new int[0][];\n    }\n}\n\n// Common ForkJoinPool\nForkJoinPool commonPool = ForkJoinPool.commonPool();\nSystem.out.println(\"Parallelism: \" + commonPool.getParallelism());"
  },
  {
    id: 96,
    category: "Advanced Threading (Senior)",
    question: "Virtual Threads (Project Loom) nima? (Java 19+)",
    answer: "Virtual Threads - lightweight threadlar (Java 19 preview, Java 21 release). Platform threadlar emas, JVM tomonidan boshqariladi. Millionlab virtual threadlar yaratish mumkin. Blocking operations virtual thread ni suspend qiladi, platform thread ni emas. Thread.startVirtualThread() yoki Executors.newVirtualThreadPerTaskExecutor(). Structured Concurrency bilan birga. Async code ni sync kabi yozish mumkin. I/O-bound applicationlar uchun ideal. CPU-bound uchun platform threadlar yaxshi. Spring Boot 3+ qo'llab-quvvatlaydi.",
    example: "// Virtual Thread yaratish (Java 21+)\nThread vThread = Thread.ofVirtual().start(() -> {\n    System.out.println(\"Virtual thread: \" + Thread.currentThread());\n});\nvThread.join();\n\n// Factory\nThreadFactory factory = Thread.ofVirtual().factory();\nThread vt = factory.newThread(() -> System.out.println(\"Running\"));\nvt.start();\n\n// Executor with virtual threads\nExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();\ntry (executor) {\n    for (int i = 0; i < 1_000_000; i++) {\n        executor.submit(() -> {\n            // Har bir task o'z virtual threadida\n            Thread.sleep(1000);\n            return \"Done\";\n        });\n    }\n} // Auto-close\n\n// Platform thread vs Virtual thread\n// Platform thread - expensive\nThread platformThread = new Thread(() -> {\n    // Heavy OS thread\n});\n\n// Virtual thread - cheap\nThread virtualThread = Thread.startVirtualThread(() -> {\n    // Lightweight, JVM managed\n});\n\n// Blocking I/O - virtual thread da optimal\nvoid handleRequest() throws Exception {\n    Thread.startVirtualThread(() -> {\n        try {\n            // Blocking call - virtual thread suspend bo'ladi\n            String data = httpClient.send(request);\n            \n            // Database call - blocking\n            User user = database.query(\"SELECT ...\");\n            \n            // Platform thread bo'sh qoladi!\n        } catch (Exception e) {}\n    });\n}\n\n// Structured Concurrency (Preview)\nclass StructuredConcurrencyExample {\n    User getUserWithOrders(Long userId) throws Exception {\n        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n            // Parallel tasks\n            Supplier<User> userTask = scope.fork(() -> fetchUser(userId));\n            Supplier<List<Order>> ordersTask = scope.fork(() -> fetchOrders(userId));\n            \n            // Wait for both\n            scope.join();\n            scope.throwIfFailed();\n            \n            // Get results\n            User user = userTask.get();\n            List<Order> orders = ordersTask.get();\n            \n            user.setOrders(orders);\n            return user;\n        }\n    }\n}\n\n// Migration guide: Platform -> Virtual\n// Before: Thread pool\nExecutorService executor = Executors.newFixedThreadPool(100);\nfor (int i = 0; i < 10000; i++) {\n    executor.submit(task);\n}\n\n// After: Virtual threads\ntry (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n    for (int i = 0; i < 10000; i++) {\n        executor.submit(task);\n    }\n}\n\n// Performance comparison\nclass PerformanceTest {\n    void platformThreads() {\n        ExecutorService executor = Executors.newFixedThreadPool(100);\n        for (int i = 0; i < 10000; i++) {\n            executor.submit(() -> {\n                Thread.sleep(1000); // Blocking\n            });\n        }\n        // 10000 / 100 = 100 seconds\n    }\n    \n    void virtualThreads() {\n        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            for (int i = 0; i < 10000; i++) {\n                executor.submit(() -> {\n                    Thread.sleep(1000); // Blocking\n                });\n            }\n        }\n        // ~1 second! (parallel)\n    }\n}\n\n// Spring Boot 3 with Virtual Threads\n// application.properties\nspring.threads.virtual.enabled=true\n\n// Controller\n@RestController\npublic class UserController {\n    @GetMapping(\"/users/{id}\")\n    public User getUser(@PathVariable Long id) {\n        // Automatically runs in virtual thread\n        return userService.findById(id);\n    }\n}"
  },
  {
    id: 97,
    category: "Advanced Threading (Senior)",
    question: "Thread Pool tuning va best practicelar qanday?",
    answer: "Thread Pool tuning - applicationning performance va resource utilizationni optimizatsiya qilish. Core pool size, max pool size, queue capacity, keep-alive time sozlash kerak. CPU-bound: poolSize = CPU cores. I/O-bound: poolSize = CPU cores * (1 + wait time / compute time). RejectedExecutionHandler - queue to'lganda. ThreadFactory - custom threadlar. Monitoring - active threads, queue size, completed tasks. Graceful shutdown. Thread pool reuse. Task granularity. Avoid thread starvation. Choose right pool type.",
    example: "// ThreadPoolExecutor - custom configuration\nThreadPoolExecutor executor = new ThreadPoolExecutor(\n    5,                      // corePoolSize\n    10,                     // maximumPoolSize\n    60L,                    // keepAliveTime\n    TimeUnit.SECONDS,       // time unit\n    new ArrayBlockingQueue<>(100),  // workQueue\n    new CustomThreadFactory(),      // threadFactory\n    new ThreadPoolExecutor.CallerRunsPolicy()  // rejectedExecutionHandler\n);\n\n// Custom ThreadFactory\nclass CustomThreadFactory implements ThreadFactory {\n    private final AtomicInteger threadNumber = new AtomicInteger(1);\n    private final String namePrefix;\n    \n    public CustomThreadFactory(String namePrefix) {\n        this.namePrefix = namePrefix;\n    }\n    \n    @Override\n    public Thread newThread(Runnable r) {\n        Thread thread = new Thread(r, namePrefix + \"-\" + threadNumber.getAndIncrement());\n        thread.setDaemon(false);\n        thread.setPriority(Thread.NORM_PRIORITY);\n        return thread;\n    }\n}\n\n// Rejection Policies\n// 1. AbortPolicy (default) - RejectedExecutionException\n// 2. CallerRunsPolicy - caller thread bajaradi\n// 3. DiscardPolicy - taskni tashlab yuboradi\n// 4. DiscardOldestPolicy - eng eski taskni o'chiradi\n\n// Custom rejection handler\nclass CustomRejectionHandler implements RejectedExecutionHandler {\n    @Override\n    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n        // Log, retry, queue to external system, etc.\n        System.err.println(\"Task rejected: \" + r.toString());\n    }\n}\n\n// Pool size calculation\nclass PoolSizeCalculator {\n    // CPU-bound tasks\n    public static int cpuBoundPoolSize() {\n        return Runtime.getRuntime().availableProcessors();\n    }\n    \n    // I/O-bound tasks\n    public static int ioBoundPoolSize(double waitTimeRatio) {\n        int cores = Runtime.getRuntime().availableProcessors();\n        // poolSize = cores * (1 + waitTime / computeTime)\n        return (int) (cores * (1 + waitTimeRatio));\n    }\n}\n\n// Monitoring\nclass ThreadPoolMonitor {\n    public void monitor(ThreadPoolExecutor executor) {\n        System.out.println(\"Pool Size: \" + executor.getPoolSize());\n        System.out.println(\"Active Threads: \" + executor.getActiveCount());\n        System.out.println(\"Completed Tasks: \" + executor.getCompletedTaskCount());\n        System.out.println(\"Total Tasks: \" + executor.getTaskCount());\n        System.out.println(\"Queue Size: \" + executor.getQueue().size());\n        System.out.println(\"Largest Pool Size: \" + executor.getLargestPoolSize());\n    }\n}\n\n// Graceful shutdown\nclass ShutdownExample {\n    public void shutdown(ExecutorService executor) {\n        executor.shutdown(); // New tasklarni qabul qilmaydi\n        try {\n            // 60 soniya kutish\n            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n                // Force shutdown\n                List<Runnable> droppedTasks = executor.shutdownNow();\n                System.out.println(\"Dropped tasks: \" + droppedTasks.size());\n                \n                // Interrupt\n                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n                    System.err.println(\"Pool did not terminate\");\n                }\n            }\n        } catch (InterruptedException e) {\n            executor.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\n// Best Practices\nclass BestPractices {\n    // 1. Always shutdown\n    void alwaysShutdown() {\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n        try {\n            // use executor\n        } finally {\n            executor.shutdown();\n        }\n    }\n    \n    // 2. Named threads\n    void namedThreads() {\n        ThreadFactory factory = new CustomThreadFactory(\"worker\");\n        ExecutorService executor = Executors.newFixedThreadPool(10, factory);\n    }\n    \n    // 3. Bounded queue\n    void boundedQueue() {\n        // Unbounded queue - OutOfMemoryError!\n        // ExecutorService bad = Executors.newFixedThreadPool(10);\n        \n        // Bounded queue\n        ThreadPoolExecutor good = new ThreadPoolExecutor(\n            10, 10, 0L, TimeUnit.MILLISECONDS,\n            new ArrayBlockingQueue<>(1000)\n        );\n    }\n    \n    // 4. Handle exceptions\n    void handleExceptions() {\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n        executor.submit(() -> {\n            try {\n                // work\n            } catch (Exception e) {\n                // handle or log\n            }\n        });\n    }\n    \n    // 5. Task granularity\n    void taskGranularity() {\n        // Too fine-grained - overhead\n        for (int i = 0; i < 1000000; i++) {\n            executor.submit(() -> System.out.println(\"x\")); // BAD\n        }\n        \n        // Better - batch tasks\n        int batchSize = 1000;\n        for (int i = 0; i < 1000000; i += batchSize) {\n            final int start = i;\n            executor.submit(() -> {\n                for (int j = start; j < start + batchSize; j++) {\n                    System.out.println(\"x\");\n                }\n            });\n        }\n    }\n}"
  },

  // Exception Handling
  {
    id: 21,
    category: "Exception Handling",
    question: "Checked va Unchecked exceptionlar o'rtasidagi farq nima?",
    answer: "Checked exceptions - bu kompilyatsiya vaqtida tekshiriladigan exceptionlar bo'lib, ularni handle qilish yoki throws declaration qilish majburiy. IOException, SQLException kabi exceptionlar checked hisoblanadi. Unchecked exceptions - bu runtime da yuzaga keluvchi exceptionlar bo'lib, RuntimeException va uning subclasslarini o'z ichiga oladi. NullPointerException, ArrayIndexOutOfBoundsException kabi. Ularni handle qilish majburiy emas.",
    example: "// Checked exception\npublic void readFile() throws IOException {\n    FileReader file = new FileReader(\"file.txt\"); // IOException\n}\n\n// Yoki try-catch bilan\npublic void readFile() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n// Unchecked exception\nint[] arr = new int[5];\narr[10] = 1; // ArrayIndexOutOfBoundsException - handle qilish shart emas"
  },
  {
    id: 22,
    category: "Exception Handling",
    question: "try-catch-finally bloki qanday ishlaydi?",
    answer: "try bloki - exception yuzaga kelishi mumkin bo'lgan kod joylashadi. catch bloki - exceptionni tutish va handle qilish uchun ishlatiladi. Ko'p catch bloklari bo'lishi mumkin. finally bloki - har doim bajariladi, exception bo'lsa ham bo'lmasa ham. Resurslarni yopish uchun ishlatiladi. Try-with-resources (Java 7+) avtomatik resurs boshqarishni ta'minlaydi.",
    example: "try {\n    int result = 10 / 0; // ArithmeticException\n} catch (ArithmeticException e) {\n    System.out.println(\"Division by zero\");\n} catch (Exception e) {\n    System.out.println(\"General exception\");\n} finally {\n    System.out.println(\"Always executed\");\n}\n\n// Try-with-resources\ntry (FileReader reader = new FileReader(\"file.txt\")) {\n    // use reader\n} catch (IOException e) {\n    e.printStackTrace();\n} // reader avtomatik yopiladi"
  },
  {
    id: 23,
    category: "Exception Handling",
    question: "throw va throws keywordlari farqi nima?",
    answer: "throw - bu exception obyektini tashlash (throw qilish) uchun ishlatiladi. Metod ichida exception yuzaga keltirish uchun ishlatiladi. throws - bu method signature da exception declare qilish uchun ishlatiladi. Metodning qaysi exceptionlarni tashlashi mumkinligini bildiradi. throw bitta exception oladi, throws bir nechta exception turlarini qabul qilishi mumkin.",
    example: "// throw - exception tashlash\npublic void validateAge(int age) {\n    if (age < 18) {\n        throw new IllegalArgumentException(\"Age must be 18+\");\n    }\n}\n\n// throws - exception declare qilish\npublic void readFile() throws IOException, FileNotFoundException {\n    FileReader file = new FileReader(\"file.txt\");\n    // IOException yuzaga kelishi mumkin\n}\n\n// Custom exception\npublic void withdraw(int amount) throws InsufficientFundsException {\n    if (balance < amount) {\n        throw new InsufficientFundsException(\"Not enough money\");\n    }\n}"
  },
  {
    id: 24,
    category: "Exception Handling",
    question: "Custom exception qanday yaratiladi?",
    answer: "Custom exception yaratish uchun Exception (checked) yoki RuntimeException (unchecked) klassidan extend qilish kerak. O'z constructor laringizni yozishingiz mumkin. getMessage(), toString() kabi metodlarni override qilish ixtiyoriy. Custom exceptionlar maxsus biznes logika uchun foydali.",
    example: "// Checked custom exception\npublic class InsufficientFundsException extends Exception {\n    private double amount;\n    \n    public InsufficientFundsException(double amount) {\n        super(\"Insufficient funds: \" + amount);\n        this.amount = amount;\n    }\n    \n    public double getAmount() {\n        return amount;\n    }\n}\n\n// Unchecked custom exception\npublic class InvalidUserException extends RuntimeException {\n    public InvalidUserException(String message) {\n        super(message);\n    }\n}\n\n// Ishlatish\npublic void withdraw(double amount) throws InsufficientFundsException {\n    if (balance < amount) {\n        throw new InsufficientFundsException(amount);\n    }\n}"
  },
  {
    id: 25,
    category: "Exception Handling",
    question: "Exception handling best practicelar qanday?",
    answer: "1) Specific exceptionlarni catch qiling, generic Exception dan qoching. 2) Exception log qiling va meaningful message bering. 3) Exceptionlarni yutmang (empty catch block). 4) Finally blokida resurslarni yoping yoki try-with-resources ishlating. 5) Custom exceptionlar yarating. 6) Unchecked exceptionlar faqat programming errorlar uchun. 7) Exception chaining ishlatib, original exceptionni saqlab qoling.",
    example: "// Yaxshi practice\ntry {\n    // code\n} catch (FileNotFoundException e) {\n    logger.error(\"File not found: \" + filename, e);\n    throw new DataAccessException(\"Cannot load data\", e); // chaining\n} catch (IOException e) {\n    logger.error(\"IO error\", e);\n    throw new DataAccessException(\"IO error\", e);\n}\n\n// Yomon practice\ntry {\n    // code\n} catch (Exception e) { // juda generic\n    // empty catch - exception yutildi!\n}"
  },

  // Stream API
  {
    id: 26,
    category: "Stream API",
    question: "Java Stream API nima va nima uchun ishlatiladi?",
    answer: "Stream API (Java 8+) - bu kolleksiyalarni functional programming uslubida ishlash uchun mo'ljallangan API. Stream - bu element ketma-ketligi bo'lib, ularga turli operatsiyalar qo'llash mumkin. Intermediate operationslar (filter, map, sorted) lazy bo'lib, terminal operation chaqirilgunga qadar bajarilmaydi. Terminal operations (collect, forEach, reduce) natija beradi va streamni yopadi. Kod qisqaradi, o'qish osonlashadi va parallel processing oson amalga oshadi.",
    example: "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);\n\n// Filter va map\nList<Integer> result = numbers.stream()\n    .filter(n -> n % 2 == 0) // faqat juft sonlar\n    .map(n -> n * 2) // har birini 2 ga ko'paytrish\n    .collect(Collectors.toList()); // [4, 8, 12]\n\n// Sum\nint sum = numbers.stream()\n    .filter(n -> n > 2)\n    .mapToInt(Integer::intValue)\n    .sum();"
  },
  {
    id: 27,
    category: "Stream API",
    question: "map() va flatMap() metodlari farqi nima?",
    answer: "map() - har bir elementni boshqa qiymatga transform qiladi va Stream<R> qaytaradi. Bir elementdan bir element hosil qiladi. flatMap() - har bir elementni Stream ga aylantradi va keyin barcha streamlarni bitta streamga birlashtiradi (flatten). Nested strukturalarni tekislash uchun ishlatiladi. Bir elementdan ko'p elementlar hosil qilishi mumkin.",
    example: "List<String> words = Arrays.asList(\"Hello\", \"World\");\n\n// map - har bir stringni uning uzunligiga o'zgartiradi\nList<Integer> lengths = words.stream()\n    .map(String::length)\n    .collect(Collectors.toList()); // [5, 5]\n\n// flatMap - har bir stringni harflarga ajratadi\nList<String> letters = words.stream()\n    .flatMap(word -> Arrays.stream(word.split(\"\")))\n    .collect(Collectors.toList()); // [H, e, l, l, o, W, o, r, l, d]\n\n// Nested list bilan\nList<List<Integer>> nested = Arrays.asList(\n    Arrays.asList(1, 2),\n    Arrays.asList(3, 4)\n);\nList<Integer> flat = nested.stream()\n    .flatMap(List::stream)\n    .collect(Collectors.toList()); // [1, 2, 3, 4]"
  },
  {
    id: 28,
    category: "Stream API",
    question: "filter() va reduce() metodlari qanday ishlaydi?",
    answer: "filter() - streamdagi elementlarni berilgan predicate bo'yicha filtrlaydi. Faqat shart bajarilgan elementlarni qoldiradi. Intermediate operation. reduce() - streamning barcha elementlarini bitta qiymatga kamaytiradi (reduce qiladi). Accumulator function ishlatadi. Terminal operation. Optional qaytaradi (stream bo'sh bo'lishi mumkin).",
    example: "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);\n\n// filter - faqat juft sonlar\nList<Integer> evens = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .collect(Collectors.toList()); // [2, 4, 6]\n\n// reduce - barcha sonlarni yig'ish\nint sum = numbers.stream()\n    .reduce(0, (a, b) -> a + b); // 21\n// yoki\nint sum2 = numbers.stream()\n    .reduce(0, Integer::sum);\n\n// reduce - eng katta qiymat\nOptional<Integer> max = numbers.stream()\n    .reduce(Integer::max); // Optional[6]\n\n// reduce - stringlarni birlashtirish\nString joined = Stream.of(\"a\", \"b\", \"c\")\n    .reduce(\"\", (s1, s2) -> s1 + s2); // \"abc\""
  },
  {
    id: 29,
    category: "Stream API",
    question: "Collectors nima va qanday ishlatiladi?",
    answer: "Collectors - bu Stream elementlarini yig'ish (collect) uchun turli strategiyalarni taqdim etuvchi utility klass. toList(), toSet(), toMap() - kolleksiyalarga o'tkazish. joining() - stringlarni birlashtirish. groupingBy() - elementlarni guruhlash. partitioningBy() - ikkiga bo'lish. counting(), summingInt(), averagingInt() - statistik operatsiyalar.",
    example: "List<String> names = Arrays.asList(\"Ali\", \"Vali\", \"Salim\", \"Olim\");\n\n// toList\nList<String> list = names.stream()\n    .filter(n -> n.length() > 3)\n    .collect(Collectors.toList());\n\n// joining\nString joined = names.stream()\n    .collect(Collectors.joining(\", \")); // \"Ali, Vali, Salim, Olim\"\n\n// groupingBy - uzunlik bo'yicha guruhlash\nMap<Integer, List<String>> grouped = names.stream()\n    .collect(Collectors.groupingBy(String::length));\n// {3=[Ali], 4=[Vali, Olim], 5=[Salim]}\n\n// counting\nlong count = names.stream()\n    .collect(Collectors.counting());\n\n// toMap\nMap<String, Integer> map = names.stream()\n    .collect(Collectors.toMap(\n        name -> name,\n        String::length\n    ));"
  },
  {
    id: 30,
    category: "Stream API",
    question: "Parallel stream qanday ishlaydi va qachon ishlatiladi?",
    answer: "Parallel stream - streamni parallel ravishda ishlashni ta'minlaydi va ForkJoinPool dan foydalanadi. parallelStream() yoki parallel() metodlari orqali yaratiladi. Katta data setlar uchun performance ni oshiradi. Lekin har doim tezroq emas - kichik data setlar uchun overhead ko'proq bo'lishi mumkin. Thread-safety, order preservation va stateful operationslar bilan ehtiyot bo'lish kerak.",
    example: "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n// Sequential stream\nlong sum1 = numbers.stream()\n    .mapToInt(Integer::intValue)\n    .sum();\n\n// Parallel stream\nlong sum2 = numbers.parallelStream()\n    .mapToInt(Integer::intValue)\n    .sum();\n\n// Sequential ni parallel ga o'zgartirish\nlong sum3 = numbers.stream()\n    .parallel()\n    .mapToInt(Integer::intValue)\n    .sum();\n\n// Qachon ishlatish kerak:\n// - Katta data setlar (10,000+ elements)\n// - CPU-intensive operationslar\n// - Independent operationslar (no shared state)"
  },

  // JVM & Memory Model
  {
    id: 31,
    category: "JVM",
    question: "JVM memory strukturasi qanday?",
    answer: "JVM memory bir nechta qismlarga bo'linadi: 1) Heap - obyektlar va array lar saqlanadigan joy. Garbage Collection bu yerda ishlaydi. Young Generation (Eden, S0, S1) va Old Generation ga bo'linadi. 2) Stack - har bir thread uchun alohida. Method chaqiruvlari, local variablelar va referencelar saqlanadi. 3) Method Area (Metaspace Java 8+) - class metadata, static variablelar, constant pool. 4) PC Register - har bir thread uchun joriy instruction. 5) Native Method Stack - native metodlar uchun.",
    example: "// Heap\nString str = new String(\"Hello\"); // obyekt heap da\nint[] arr = new int[10]; // array heap da\n\n// Stack\nvoid method() {\n    int x = 10; // primitive stack da\n    String name = \"Ali\"; // reference stack da, obyekt heap da\n}\n\n// Method Area\nclass MyClass {\n    static int count = 0; // static variable Method Area da\n}\n\n// JVM argumentlari\n// -Xms512m (initial heap size)\n// -Xmx2g (maximum heap size)\n// -Xss1m (stack size per thread)"
  },
  {
    id: 32,
    category: "JVM",
    question: "Garbage Collection qanday ishlaydi?",
    answer: "Garbage Collection (GC) - bu JVM ning avtomatik memory management mexanizmi. Unreachable obyektlarni aniqlaydi va o'chiradi. Mark-Sweep-Compact algoritmidan foydalanadi. Young Generation da Minor GC (tez-tez), Old Generation da Major GC (kamdan-kam) sodir bo'ladi. Turli GC algoritmlar mavjud: Serial GC, Parallel GC, CMS, G1 (default Java 9+), ZGC va Shenandoah. finalize() metodi deprecated.",
    example: "// Obyekt GC uchun tayyor\nString str = new String(\"Hello\");\nstr = null; // eski obyekt unreachable bo'ldi\n\n// Reference turlar\n// Strong reference (oddiy)\nObject obj = new Object();\n\n// Weak reference\nWeakReference<Object> weak = new WeakReference<>(new Object());\n// GC ishlasa, weak reference bo'sh bo'ladi\n\n// Soft reference\nSoftReference<Object> soft = new SoftReference<>(new Object());\n// Memory kam qolganda GC soft referencelarni o'chiradi\n\n// GC ni qo'lda chaqirish (tavsiya etilmaydi)\nSystem.gc();\n// Lekin bu faqat hint, kafolat emas"
  },
  {
    id: 33,
    category: "JVM",
    question: "OutOfMemoryError qanday holatlarda yuzaga keladi?",
    answer: "OutOfMemoryError - bu JVM da memory tugagan holatlarda yuzaga keladi. Turli xil sabablari bor: 1) Heap space - heap to'lib ketgan (ko'p obyektlar yaratilgan yoki memory leak). 2) Metaspace - class metadata uchun joy tugagan. 3) Stack overflow - rekursiya juda chuqur yoki stack hajmi kichik. 4) Direct buffer memory - NIO bufferlar uchun joy tugagan. Memory leak, inefficient code yoki noto'g'ri JVM konfiguratsiya sababchi bo'lishi mumkin.",
    example: "// Heap space OOM\nList<byte[]> list = new ArrayList<>();\nwhile (true) {\n    list.add(new byte[1024 * 1024]); // har safar 1MB qo'shiladi\n}\n// java.lang.OutOfMemoryError: Java heap space\n\n// StackOverflowError\npublic void recursive() {\n    recursive(); // cheksiz rekursiya\n}\n// java.lang.StackOverflowError\n\n// Metaspace OOM (ko'p class loading)\nwhile (true) {\n    ClassLoader loader = new CustomClassLoader();\n    loader.loadClass(\"MyClass\");\n}\n// java.lang.OutOfMemoryError: Metaspace\n\n// Yechimlar:\n// - Heap size oshirish: -Xmx4g\n// - Memory leak topish: profiler ishlatish\n// - Code optimization"
  },
  {
    id: 34,
    category: "JVM",
    question: "Java da memory leak qanday yuzaga keladi?",
    answer: "Java avtomatik GC ga ega bo'lsa ham, memory leak yuzaga kelishi mumkin. Asosiy sabablar: 1) Static collections - static larga qo'shilgan obyektlar GC qilinmaydi. 2) Listener va callback lar - unregister qilinmagan listenerlar. 3) ThreadLocal o'zgaruvchilar - tozalanmagan ThreadLocal lar. 4) Unclosed resources - yopilmagan file, connection, stream lar. 5) Hashcode va equals implementation xatosi. 6) Inner class referencelar - non-static inner classlar outer classga reference saqlaydi.",
    example: "// Memory leak misoli - static collection\npublic class Cache {\n    private static final Map<String, Object> cache = new HashMap<>();\n    \n    public void add(String key, Object value) {\n        cache.put(key, value); // hech qachon tozalanmaydi!\n    }\n}\n\n// Listener leak\nbutton.addActionListener(listener);\n// button o'chirilganda listener ham o'chirilishi kerak\nbutton.removeActionListener(listener);\n\n// ThreadLocal leak\nThreadLocal<String> threadLocal = new ThreadLocal<>();\nthreadLocal.set(\"value\");\n// ishlatib bo'lgandan keyin:\nthreadLocal.remove(); // bu majburiy!\n\n// Resource leak\nFileInputStream fis = new FileInputStream(\"file.txt\");\n// fis.close(); ni unutish - leak!\n\n// To'g'ri yechim - try-with-resources\ntry (FileInputStream fis = new FileInputStream(\"file.txt\")) {\n    // use fis\n} // avtomatik yopiladi"
  },
  {
    id: 35,
    category: "JVM",
    question: "Java Class Loading mexanizmi qanday ishlaydi?",
    answer: "Class loading uch bosqichda amalga oshadi: 1) Loading - class bytecode ni memory ga yuklash. ClassLoader hierarchy: Bootstrap (JDK classes), Extension (ext folder), Application (classpath). 2) Linking - Verification (bytecode to'g'riligini tekshirish), Preparation (static field lar uchun joy ajratish), Resolution (symbolic reference larni direct referencega aylantirish). 3) Initialization - static initialization bloklari va static fieldlarni boshlang'ich qiymat bilan to'ldirish. Lazy loading qo'llaniladi.",
    example: "// Class loading hierarchy\nClassLoader loader = MyClass.class.getClassLoader();\nSystem.out.println(loader); // Application ClassLoader\nSystem.out.println(loader.getParent()); // Platform/Extension ClassLoader\nSystem.out.println(loader.getParent().getParent()); // null (Bootstrap)\n\n// Custom ClassLoader\npublic class CustomClassLoader extends ClassLoader {\n    @Override\n    public Class<?> findClass(String name) {\n        byte[] classData = loadClassData(name);\n        return defineClass(name, classData, 0, classData.length);\n    }\n}\n\n// Class initialization order\nclass Parent {\n    static { System.out.println(\"Parent static\"); }\n    { System.out.println(\"Parent instance\"); }\n}\nclass Child extends Parent {\n    static { System.out.println(\"Child static\"); }\n    { System.out.println(\"Child instance\"); }\n}\nnew Child();\n// Output:\n// Parent static\n// Child static\n// Parent instance\n// Child instance"
  },

  // Generics
  {
    id: 36,
    category: "Generics",
    question: "Generics nima va nima uchun kerak?",
    answer: "Generics (Java 5+) - bu type safety va code reusability ni ta'minlaydigan mexanizm. Type parameterlarni qo'llash orqali bir xil kodni turli xil tiplar bilan ishlashga imkon beradi. Compile-time type checking ta'minlaydi va runtime ClassCastException larni oldini oladi. Type casting kerak bo'lmaydi. Collections, Custom classes va metodlarda ishlatiladi.",
    example: "// Generics ishlatmasdan (eski usul)\nList list = new ArrayList();\nlist.add(\"Hello\");\nlist.add(123);\nString str = (String) list.get(0); // casting kerak\n\n// Generics bilan\nList<String> list = new ArrayList<>();\nlist.add(\"Hello\");\n// list.add(123); // Compile error - type safe!\nString str = list.get(0); // casting kerak emas\n\n// Generic class\nclass Box<T> {\n    private T content;\n    \n    public void set(T content) {\n        this.content = content;\n    }\n    \n    public T get() {\n        return content;\n    }\n}\n\nBox<String> stringBox = new Box<>();\nstringBox.set(\"Hello\");\nString value = stringBox.get();"
  },
  {
    id: 37,
    category: "Generics",
    question: "Bounded Type Parameters nima?",
    answer: "Bounded Type Parameters - bu generic tipni cheklash imkonini beradi. extends keyword bilan upper bound (yuqori chegara) belgilanadi. Bir yoki bir nechta interfacelar bilan ham cheklanishi mumkin. super keyword bilan lower bound belgilanadi (wildcard bilan). Cheklangan tiplar faqat belgilangan tip yoki uning subclasslari bo'lishi mumkin. Bu type safety ni oshiradi va muayyan metodlarni chaqirishga imkon beradi.",
    example: "// Upper bound - faqat Number va uning subclasslari\nclass Calculator<T extends Number> {\n    private T value;\n    \n    public double doubleValue() {\n        return value.doubleValue(); // Number metodini chaqirish mumkin\n    }\n}\n\nCalculator<Integer> intCalc = new Calculator<>();\nCalculator<Double> doubleCalc = new Calculator<>();\n// Calculator<String> strCalc = new Calculator<>(); // Compile error!\n\n// Multiple bounds\nclass MyClass<T extends Number & Comparable<T>> {\n    // T Number va Comparable ni implement qilishi kerak\n}\n\n// Wildcard bilan\npublic void processList(List<? extends Number> list) {\n    for (Number num : list) {\n        System.out.println(num.doubleValue());\n    }\n}\n\nprocesssList(Arrays.asList(1, 2, 3)); // Integer\nprocesssList(Arrays.asList(1.5, 2.5)); // Double"
  },
  {
    id: 38,
    category: "Generics",
    question: "Wildcard (?) nima va qachon ishlatiladi?",
    answer: "Wildcard (?) - bu noma'lum tipni bildiradi. Uch xil wildcard mavjud: 1) Unbounded wildcard <?> - har qanday tip. 2) Upper bounded wildcard <? extends Type> - Type yoki uning subclasslari. Read-only operatsiyalar uchun ishlatiladi (PECS - Producer Extends). 3) Lower bounded wildcard <? super Type> - Type yoki uning superclasslari. Write operatsiyalar uchun ishlatiladi (PECS - Consumer Super).",
    example: "// Unbounded wildcard\npublic void printList(List<?> list) {\n    for (Object obj : list) {\n        System.out.println(obj);\n    }\n}\n\n// Upper bounded - PRODUCER\npublic double sumOfList(List<? extends Number> list) {\n    double sum = 0;\n    for (Number num : list) {\n        sum += num.doubleValue();\n    }\n    return sum;\n}\n// list.add(new Integer(5)); // Compile error - faqat o'qish!\n\n// Lower bounded - CONSUMER\npublic void addNumbers(List<? super Integer> list) {\n    list.add(1);\n    list.add(2);\n    list.add(3);\n}\n// Integer value = list.get(0); // Compile error - faqat yozish!\n\n// PECS qoidasi:\n// Producer Extends, Consumer Super\nList<? extends Number> producer = new ArrayList<Integer>();\nList<? super Integer> consumer = new ArrayList<Number>();"
  },
  {
    id: 39,
    category: "Generics",
    question: "Type Erasure nima va qanday ishlaydi?",
    answer: "Type Erasure - bu compile vaqtida generics ma'lumotlarini o'chirish (erase) jarayoni. Java genericsni backward compatibility uchun bytecode levelda implement qilmaydi. Compile vaqtida barcha type parameterlar o'chiriladi va Object yoki bounded type bilan almashtiriladi. Runtime da generic tip ma'lumoti yo'q. Shuning uchun instanceof va new operatorlarida generic ishlatib bo'lmaydi.",
    example: "// Original kod\nList<String> stringList = new ArrayList<>();\nList<Integer> intList = new ArrayList<>();\n\n// Compile qilingandan keyin (Type Erasure)\nList stringList = new ArrayList();\nList intList = new ArrayList();\n\n// Runtime da ikkalasi ham bir xil tip!\nstringList.getClass() == intList.getClass(); // true\n\n// Muammolar\n// 1. instanceof ishlamaydi\nif (list instanceof List<String>) { } // Compile error\nif (list instanceof List<?>) { } // To'g'ri\n\n// 2. Generic array yaratib bo'lmaydi\nList<String>[] array = new List<String>[10]; // Compile error\nList<?>[] array = new List<?>[10]; // To'g'ri\n\n// 3. Static contextda generic ishlatib bo'lmaydi\nclass MyClass<T> {\n    // static T value; // Compile error\n    // static void method(T param) { } // Compile error\n}"
  },
  {
    id: 40,
    category: "Generics",
    question: "Generic metodlar qanday yaratiladi?",
    answer: "Generic metodlar - bu o'z type parameterlariga ega bo'lgan metodlar. Metodning return type dan oldin <T> ko'rinishida type parameter deklaratsiya qilinadi. Generic metodlar static ham, instance ham bo'lishi mumkin. Class generic bo'lmasa ham, method generic bo'lishi mumkin. Type inference - kompilyator tip ni avtomatik aniqlaydi.",
    example: "// Generic method\npublic class Util {\n    // Static generic method\n    public static <T> void printArray(T[] array) {\n        for (T element : array) {\n            System.out.println(element);\n        }\n    }\n    \n    // Type inference\n    public static <T> T getFirst(List<T> list) {\n        return list.isEmpty() ? null : list.get(0);\n    }\n}\n\n// Ishlatish\nInteger[] intArray = {1, 2, 3};\nString[] strArray = {\"A\", \"B\", \"C\"};\n\nUtil.<Integer>printArray(intArray); // explicit\nUtil.printArray(intArray); // type inference\nUtil.printArray(strArray);\n\n// Bounded generic method\npublic static <T extends Comparable<T>> T max(T a, T b) {\n    return a.compareTo(b) > 0 ? a : b;\n}\n\nInteger maxInt = max(5, 10); // 10\nString maxStr = max(\"apple\", \"banana\"); // \"banana\""
  },

  // SOLID Prinsiplari
  {
    id: 41,
    category: "SOLID",
    question: "SOLID prinsiplari nima?",
    answer: "SOLID - bu obyekt-oriented dasturlashda 5 ta asosiy design prinsiplari: S - Single Responsibility Principle, O - Open/Closed Principle, L - Liskov Substitution Principle, I - Interface Segregation Principle, D - Dependency Inversion Principle. Bu prinsiplar kodni maintainable, flexible va scalable qilish uchun ishlatiladi. Uncle Bob (Robert Martin) tomonidan kiritilgan.",
    example: "// S - Single Responsibility\nclass User {\n    private String name;\n    // Faqat user ma'lumotlarini saqlaydi\n}\n\nclass UserRepository {\n    // Faqat DB operatsiyalari\n}\n\nclass UserValidator {\n    // Faqat validation\n}\n\n// Har bir klass bitta vazifaga ega"
  },
  {
    id: 42,
    category: "SOLID",
    question: "Single Responsibility Principle (SRP) nima?",
    answer: "Single Responsibility Principle - har bir klass faqat bitta vazifaga (responsibility) ega bo'lishi kerak va o'zgarish uchun faqat bitta sabab bo'lishi kerak. Agar klass ko'p vazifalarni bajarsa, bir vazifadagi o'zgarish boshqa vazifalarga ta'sir qiladi. Bu kod maintainability ni oshiradi, testing ni osonlashtiradi va coupling ni kamaytiradi.",
    example: "// SRP buzilgan\nclass Employee {\n    private String name;\n    private double salary;\n    \n    public void calculateSalary() { /* ... */ }\n    public void saveToDatabase() { /* ... */ }\n    public void generateReport() { /* ... */ }\n    // 3 ta turli vazifa!\n}\n\n// SRP to'g'ri qo'llangan\nclass Employee {\n    private String name;\n    private double salary;\n    // Faqat employee data\n}\n\nclass SalaryCalculator {\n    public double calculate(Employee emp) { /* ... */ }\n}\n\nclass EmployeeRepository {\n    public void save(Employee emp) { /* ... */ }\n}\n\nclass ReportGenerator {\n    public void generate(Employee emp) { /* ... */ }\n}"
  },
  {
    id: 43,
    category: "SOLID",
    question: "Open/Closed Principle (OCP) nima?",
    answer: "Open/Closed Principle - klasslar extension uchun ochiq (open), lekin modification uchun yopiq (closed) bo'lishi kerak. Ya'ni, mavjud kodni o'zgartirmasdan yangi funksionallik qo'shish mumkin bo'lishi kerak. Bu abstraction va polymorphism orqali erishiladi. Interface va abstract class lardan foydalanish OCP ni ta'minlaydi.",
    example: "// OCP buzilgan\nclass AreaCalculator {\n    public double calculate(Object shape) {\n        if (shape instanceof Circle) {\n            Circle circle = (Circle) shape;\n            return Math.PI * circle.radius * circle.radius;\n        } else if (shape instanceof Rectangle) {\n            Rectangle rect = (Rectangle) shape;\n            return rect.width * rect.height;\n        }\n        // Har safar yangi shape uchun bu klassni o'zgartirish kerak!\n    }\n}\n\n// OCP to'g'ri qo'llangan\ninterface Shape {\n    double area();\n}\n\nclass Circle implements Shape {\n    private double radius;\n    public double area() {\n        return Math.PI * radius * radius;\n    }\n}\n\nclass Rectangle implements Shape {\n    private double width, height;\n    public double area() {\n        return width * height;\n    }\n}\n\nclass AreaCalculator {\n    public double calculate(Shape shape) {\n        return shape.area(); // Hech qachon o'zgartirilmaydi\n    }\n}"
  },
  {
    id: 44,
    category: "SOLID",
    question: "Liskov Substitution Principle (LSP) nima?",
    answer: "Liskov Substitution Principle - subclass obyektlari superclass obyektlari o'rnida ishlatilishi mumkin bo'lib, dastur to'g'ri ishlashini davom ettirishi kerak. Child class parent classning kontraktini buzmasligi kerak. Method signature, preconditions va postconditions bir xil bo'lishi kerak. Exception lar, return tiplar mos kelishi kerak.",
    example: "// LSP buzilgan\nclass Bird {\n    public void fly() {\n        System.out.println(\"Flying...\");\n    }\n}\n\nclass Penguin extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException(\"Penguins can't fly\");\n        // Parent kontraktini buzadi!\n    }\n}\n\n// LSP to'g'ri qo'llangan\ninterface Bird {\n    void eat();\n}\n\ninterface FlyingBird extends Bird {\n    void fly();\n}\n\nclass Sparrow implements FlyingBird {\n    public void eat() { /* ... */ }\n    public void fly() { /* ... */ }\n}\n\nclass Penguin implements Bird {\n    public void eat() { /* ... */ }\n    // fly() metodi yo'q - chunki penguinlar uchmaydi\n}"
  },
  {
    id: 45,
    category: "SOLID",
    question: "Interface Segregation Principle (ISP) nima?",
    answer: "Interface Segregation Principle - clientlar o'zlari ishlatmaydigan metodlarga bog'liq bo'lmasligi kerak. Katta interfacelarni kichikroq, specific interfacelarga bo'lish kerak. Fat interface lardan qochish kerak. Har bir client faqat o'ziga kerakli metodlarga ega bo'lgan interface ni implement qilishi kerak. Bu unnecessary dependencies ni kamaytiradi.",
    example: "// ISP buzilgan - Fat interface\ninterface Worker {\n    void work();\n    void eat();\n    void sleep();\n}\n\nclass HumanWorker implements Worker {\n    public void work() { /* ... */ }\n    public void eat() { /* ... */ }\n    public void sleep() { /* ... */ }\n}\n\nclass RobotWorker implements Worker {\n    public void work() { /* ... */ }\n    public void eat() { /* Robot yemaydi! */ }\n    public void sleep() { /* Robot uxlamaydi! */ }\n}\n\n// ISP to'g'ri qo'llangan\ninterface Workable {\n    void work();\n}\n\ninterface Eatable {\n    void eat();\n}\n\ninterface Sleepable {\n    void sleep();\n}\n\nclass HumanWorker implements Workable, Eatable, Sleepable {\n    public void work() { /* ... */ }\n    public void eat() { /* ... */ }\n    public void sleep() { /* ... */ }\n}\n\nclass RobotWorker implements Workable {\n    public void work() { /* ... */ }\n    // Faqat kerakli interfacelarni implement qiladi\n}"
  },

  // Best Practices
  {
    id: 46,
    category: "Best Practices",
    question: "Dependency Inversion Principle (DIP) nima?",
    answer: "Dependency Inversion Principle - yuqori darajadagi modullar past darajadagi modullarga bog'liq bo'lmasligi kerak. Ikkalasi ham abstractionlarga bog'liq bo'lishi kerak. Abstractionlar detaillarga bog'liq bo'lmasligi kerak, detaillar abstractionlarga bog'liq bo'lishi kerak. Bu loose coupling yaratadi va code ni testable qiladi. Dependency Injection (DI) orqali amalga oshiriladi.",
    example: "// DIP buzilgan - tight coupling\nclass EmailService {\n    public void sendEmail(String message) { /* ... */ }\n}\n\nclass UserController {\n    private EmailService emailService = new EmailService();\n    // To'g'ridan-to'g'ri EmailService ga bog'liq\n    \n    public void register(User user) {\n        // ...\n        emailService.sendEmail(\"Welcome\");\n    }\n}\n\n// DIP to'g'ri qo'llangan\ninterface MessageService {\n    void sendMessage(String message);\n}\n\nclass EmailService implements MessageService {\n    public void sendMessage(String message) { /* ... */ }\n}\n\nclass SMSService implements MessageService {\n    public void sendMessage(String message) { /* ... */ }\n}\n\nclass UserController {\n    private MessageService messageService;\n    \n    // Dependency Injection\n    public UserController(MessageService messageService) {\n        this.messageService = messageService;\n    }\n    \n    public void register(User user) {\n        // ...\n        messageService.sendMessage(\"Welcome\");\n    }\n}"
  },
  {
    id: 47,
    category: "Best Practices",
    question: "Immutable class qanday yaratiladi?",
    answer: "Immutable class - bu obyekt yaratilgandan keyin o'zgartirib bo'lmaydigan klass. Thread-safe va cache-friendly. Immutable class yaratish qoidalari: 1) Klassni final qilish. 2) Barcha fieldlarni private final qilish. 3) Setter metodlar yo'q. 4) Constructor orqali barcha fieldlarni initialize qilish. 5) Mutable fieldlar uchun defensive copy qaytarish. 6) Subclass yaratib bo'lmaydigan qilish.",
    example: "public final class ImmutablePerson {\n    private final String name;\n    private final int age;\n    private final List<String> hobbies;\n    \n    public ImmutablePerson(String name, int age, List<String> hobbies) {\n        this.name = name;\n        this.age = age;\n        // Defensive copy - tashqi o'zgarishlardan himoya\n        this.hobbies = new ArrayList<>(hobbies);\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public List<String> getHobbies() {\n        // Defensive copy qaytarish\n        return new ArrayList<>(hobbies);\n    }\n    \n    // Setter metodlar yo'q\n}\n\n// Ishlatish\nList<String> hobbies = Arrays.asList(\"Reading\", \"Coding\");\nImmutablePerson person = new ImmutablePerson(\"Ali\", 25, hobbies);\nhobbies.add(\"Gaming\"); // person obyektiga ta'sir qilmaydi"
  },
  {
    id: 48,
    category: "Best Practices",
    question: "Java da Singleton pattern qanday implement qilinadi?",
    answer: "Singleton pattern - bitta klassdan faqat bitta instance yaratilishini ta'minlaydi. Implement qilish usullari: 1) Eager initialization - class yuklanganda yaratiladi. 2) Lazy initialization - birinchi marta kerak bo'lganda yaratiladi. 3) Thread-safe lazy (synchronized). 4) Double-checked locking. 5) Bill Pugh Singleton (static inner class). 6) Enum singleton (eng yaxshi usul - serialization safe).",
    example: "// 1. Eager initialization\nclass Singleton {\n    private static final Singleton instance = new Singleton();\n    private Singleton() {}\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n\n// 2. Lazy initialization (thread-safe emas)\nclass Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 3. Bill Pugh Singleton (tavsiya etiladi)\nclass Singleton {\n    private Singleton() {}\n    \n    private static class SingletonHelper {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    \n    public static Singleton getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n}\n\n// 4. Enum Singleton (eng yaxshi)\nenum Singleton {\n    INSTANCE;\n    public void someMethod() { /* ... */ }\n}"
  },
  {
    id: 49,
    category: "Best Practices",
    question: "equals() va hashCode() metodlarini to'g'ri implement qilish qanday?",
    answer: "equals() va hashCode() metodlari Object klassidan meros bo'lib, ularni override qilish kerak. Contract: 1) Agar x.equals(y) true bo'lsa, x.hashCode() == y.hashCode() bo'lishi kerak. 2) Agar x.hashCode() == y.hashCode() bo'lsa, x.equals(y) true bo'lishi shart emas (collision). equals() symmetric, reflexive, transitive va consistent bo'lishi kerak. HashMap, HashSet kabi collectionlarda to'g'ri ishlashi uchun zarur.",
    example: "public class Person {\n    private String name;\n    private int age;\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true; // reflexive\n        if (o == null || getClass() != o.getClass()) return false;\n        \n        Person person = (Person) o;\n        return age == person.age && \n               Objects.equals(name, person.name);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n}\n\n// Yomon implement - hashCode() yo'q\nMap<Person, String> map = new HashMap<>();\nPerson p1 = new Person(\"Ali\", 25);\nmap.put(p1, \"Developer\");\n\nPerson p2 = new Person(\"Ali\", 25);\nmap.get(p2); // null qaytaradi (hashCode turli!)\n\n// To'g'ri implement bilan\n// map.get(p2) \"Developer\" qaytaradi"
  },
  {
    id: 50,
    category: "Best Practices",
    question: "Java performance optimization uchun best practicelar qanday?",
    answer: "Performance optimization best practicelar: 1) StringBuilder ishlatish (String concatenation o'rniga). 2) Collections initial capacity berish. 3) Primitive tiplardan foydalanish (wrapper o'rniga). 4) Lazy initialization. 5) Connection pooling. 6) Caching strategiyasi. 7) Stream API parallel stream. 8) Try-with-resources. 9) Avoid premature optimization. 10) Profiler ishlatish (JProfiler, VisualVM). 11) JVM tuning (-Xms, -Xmx, GC tuning).",
    example: "// 1. StringBuilder vs String\n// Yomon\nString result = \"\";\nfor (int i = 0; i < 1000; i++) {\n    result += i; // har safar yangi String yaratiladi!\n}\n\n// Yaxshi\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < 1000; i++) {\n    sb.append(i);\n}\nString result = sb.toString();\n\n// 2. Collections initial capacity\n// Yomon\nList<String> list = new ArrayList<>(); // default 10\nfor (int i = 0; i < 1000; i++) {\n    list.add(String.valueOf(i)); // ko'p marta resize\n}\n\n// Yaxshi\nList<String> list = new ArrayList<>(1000); // oldindan joy ajratilgan\n\n// 3. Primitive vs Wrapper\n// Yomon\nInteger sum = 0;\nfor (int i = 0; i < 1000; i++) {\n    sum += i; // autoboxing/unboxing - sekin!\n}\n\n// Yaxshi\nint sum = 0;\nfor (int i = 0; i < 1000; i++) {\n    sum += i;\n}\n\n// 4. Lazy initialization\nclass Service {\n    private ExpensiveObject obj;\n    \n    public ExpensiveObject getObject() {\n        if (obj == null) {\n            obj = new ExpensiveObject(); // faqat kerak bo'lganda yaratiladi\n        }\n        return obj;\n    }\n}"
  },

  // Spring Core (Junior)
  {
    id: 51,
    category: "Spring Core (Junior)",
    question: "Spring Framework nima va uning asosiy xususiyatlari qanday?",
    answer: "Spring - bu Java uchun eng mashhur open-source framework bo'lib, enterprise application yaratishni osonlashtiradi. Asosiy xususiyatlari: 1) IoC (Inversion of Control) - dependency lar framework tomonidan boshqariladi. 2) DI (Dependency Injection) - bog'liqliklarni avtomatik inject qilish. 3) AOP (Aspect-Oriented Programming) - cross-cutting concernlar uchun. 4) Lightweight - minimal overhead. 5) POJO-based - oddiy Java obyektlari bilan ishlaydi. 6) Modulyar - kerakli modullarni tanlash mumkin.",
    example: "// Spring modullar:\n- spring-core: asosiy IoC konteyner\n- spring-context: ApplicationContext\n- spring-beans: bean management\n- spring-aop: AOP support\n- spring-jdbc: JDBC abstraction\n- spring-orm: ORM framework support\n- spring-web: web application support\n- spring-webmvc: MVC framework"
  },
  {
    id: 52,
    category: "Spring Core (Junior)",
    question: "IoC (Inversion of Control) va Dependency Injection nima?",
    answer: "IoC (Inversion of Control) - bu design pattern bo'lib, obyekt yaratish va lifecycle boshqaruvini dasturdan framework ga o'tkazadi. Dependency Injection - IoC ni amalga oshirish usuli bo'lib, bog'liqliklarni tashqaridan inject qiladi. 3 xil DI mavjud: 1) Constructor Injection - constructor orqali (tavsiya etiladi). 2) Setter Injection - setter metodlar orqali. 3) Field Injection - to'g'ridan-to'g'ri fieldga (@Autowired).",
    example: "// Constructor Injection (eng yaxshi)\n@Service\npublic class UserService {\n    private final UserRepository repository;\n    \n    @Autowired // Spring 4.3+ da ixtiyoriy\n    public UserService(UserRepository repository) {\n        this.repository = repository;\n    }\n}\n\n// Setter Injection\n@Service\npublic class UserService {\n    private UserRepository repository;\n    \n    @Autowired\n    public void setRepository(UserRepository repository) {\n        this.repository = repository;\n    }\n}\n\n// Field Injection (tavsiya etilmaydi)\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository repository;\n}"
  },
  {
    id: 53,
    category: "Spring Core (Junior)",
    question: "Spring Bean nima va qanday yaratiladi?",
    answer: "Spring Bean - bu Spring IoC container tomonidan boshqariladigan obyekt. Bean lar configuration metadata orqali yaratiladi va lifecycle lar Spring tomonidan manage qilinadi. Bean yaratish usullari: 1) @Component va stereotype annotationlar (@Service, @Repository, @Controller). 2) @Bean annotation configuration classda. 3) XML configuration (eski usul). Component scan yordamida Spring avtomatik bean larni topadi.",
    example: "// 1. Component scanning\n@Component // yoki @Service, @Repository, @Controller\npublic class UserService { }\n\n// 2. Java Configuration\n@Configuration\npublic class AppConfig {\n    @Bean\n    public UserService userService() {\n        return new UserService();\n    }\n    \n    @Bean\n    public UserRepository userRepository() {\n        return new UserRepositoryImpl();\n    }\n}\n\n// Component Scan yoqish\n@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig { }"
  },
  {
    id: 54,
    category: "Spring Core (Junior)",
    question: "Bean Scope lari qanday va qachon ishlatiladi?",
    answer: "Bean scope - bean ning lifecycle va visibility ni belgilaydi. Asosiy scopelar: 1) singleton (default) - bitta instance butun application uchun. 2) prototype - har safar yangi instance. 3) request (web) - har bir HTTP request uchun yangi instance. 4) session (web) - har bir HTTP session uchun. 5) application (web) - ServletContext lifecycle. 6) websocket (web) - WebSocket lifecycle. Ko'pincha singleton yetarli, stateful bean lar uchun prototype ishlatiladi.",
    example: "// Singleton (default)\n@Service\npublic class UserService { }\n\n// Prototype\n@Service\n@Scope(\"prototype\") // yoki ConfigurableBeanFactory.SCOPE_PROTOTYPE\npublic class UserService { }\n\n// Request scope\n@Component\n@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class LoginAction { }\n\n// Session scope\n@Component\n@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class UserPreferences { }"
  },
  {
    id: 55,
    category: "Spring Core (Junior)",
    question: "@Component, @Service, @Repository va @Controller farqlari nima?",
    answer: "Bularning barchasi @Component ning stereotype annotation lari bo'lib, special purpose uchun ishlatiladi. @Component - generic annotation, har qanday Spring-managed component. @Service - business logic layer uchun, transaction management qo'shilishi mumkin. @Repository - persistence layer uchun, exception translation (SQL exception ni DataAccessException ga). @Controller - presentation layer uchun, MVC controller sifatida. Semantik farq bor, lekin texnik jihatdan ko'p farq yo'q.",
    example: "// Generic component\n@Component\npublic class EmailValidator { }\n\n// Service layer\n@Service\npublic class UserService {\n    @Transactional\n    public void createUser(User user) { }\n}\n\n// Persistence layer\n@Repository\npublic class UserRepositoryImpl implements UserRepository {\n    // SQLException avtomatik DataAccessException ga aylanadi\n}\n\n// Web layer\n@Controller\npublic class UserController {\n    @GetMapping(\"/users\")\n    public String getUsers(Model model) {\n        return \"users\";\n    }\n}"
  },
  {
    id: 56,
    category: "Spring Core (Junior)",
    question: "Spring Bean Lifecycle qanday ishlaydi?",
    answer: "Bean lifecycle bir nechta bosqichlardan iborат: 1) Instantiation - bean obyekti yaratiladi. 2) Populating properties - dependency injection. 3) setBeanName() - BeanNameAware. 4) setBeanFactory() - BeanFactoryAware. 5) setApplicationContext() - ApplicationContextAware. 6) postProcessBeforeInitialization() - BeanPostProcessor. 7) afterPropertiesSet() - InitializingBean yoki @PostConstruct. 8) init-method. 9) postProcessAfterInitialization() - BeanPostProcessor. 10) Bean tayyor. 11) destroy() - DisposableBean yoki @PreDestroy. 12) destroy-method.",
    example: "@Component\npublic class UserService implements InitializingBean, DisposableBean {\n    \n    // 1. Constructor\n    public UserService() {\n        System.out.println(\"Constructor called\");\n    }\n    \n    // 2. Dependency injection\n    @Autowired\n    private UserRepository repository;\n    \n    // 3. @PostConstruct\n    @PostConstruct\n    public void init() {\n        System.out.println(\"PostConstruct called\");\n    }\n    \n    // 4. InitializingBean\n    @Override\n    public void afterPropertiesSet() {\n        System.out.println(\"afterPropertiesSet called\");\n    }\n    \n    // 5. @PreDestroy\n    @PreDestroy\n    public void cleanup() {\n        System.out.println(\"PreDestroy called\");\n    }\n    \n    // 6. DisposableBean\n    @Override\n    public void destroy() {\n        System.out.println(\"destroy called\");\n    }\n}"
  },

  // Spring Boot (Junior)
  {
    id: 57,
    category: "Spring Boot (Junior)",
    question: "Spring Boot nima va Spring dan farqi nima?",
    answer: "Spring Boot - Spring Framework ustiga qurilgan tool bo'lib, production-ready Spring application yaratishni osonlashtiradi. Asosiy farqlari: 1) Auto-configuration - automatic configuration. 2) Starter dependencies - oldindan konfiguratsiya qilingan dependency lar. 3) Embedded server - Tomcat, Jetty, Undertow. 4) Production-ready features - metrics, health checks, externalized configuration. 5) No XML configuration - annotation-based. 6) Opinionated defaults - sensible defaults. Spring Boot = Spring + Auto-configuration + Embedded Server + Starters.",
    example: "// Spring Boot Application\n@SpringBootApplication // = @Configuration + @EnableAutoConfiguration + @ComponentScan\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n\n// pom.xml - Starter dependencies\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>"
  },
  {
    id: 58,
    category: "Spring Boot (Junior)",
    question: "Spring Boot Auto-Configuration qanday ishlaydi?",
    answer: "Auto-configuration - Spring Boot ning classpath dagi library larga qarab avtomatik ravishda application ni konfiguratsiya qiladi. @EnableAutoConfiguration annotation yoki @SpringBootApplication orqali yoqiladi. Conditional annotations (@ConditionalOnClass, @ConditionalOnMissingBean va boshqalar) yordamida shartli konfiguratsiya amalga oshadi. spring.factories fayli auto-configuration klasslarini ro'yxatga oladi. @AutoConfiguration annotatsiyasi bilan yaratiladi.",
    example: "// @SpringBootApplication ichida\n@SpringBootApplication\n// = @Configuration + @EnableAutoConfiguration + @ComponentScan\npublic class MyApplication { }\n\n// Auto-configuration misoli\n@Configuration\n@ConditionalOnClass(DataSource.class)\n@EnableConfigurationProperties(DataSourceProperties.class)\npublic class DataSourceAutoConfiguration {\n    \n    @Bean\n    @ConditionalOnMissingBean\n    public DataSource dataSource(DataSourceProperties properties) {\n        // DataSource yaratish\n    }\n}\n\n// Auto-configuration o'chirish\n@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\n// yoki application.properties da\nspring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration"
  },
  {
    id: 59,
    category: "Spring Boot (Junior)",
    question: "application.properties va application.yml farqi nima?",
    answer: "Ikkalasi ham Spring Boot application ni konfiguratsiya qilish uchun ishlatiladi, lekin formatda farq bor. application.properties - key-value format, oddiy va tushunarli. application.yml - YAML format, hierarchy va o'qish uchun qulay, kam takrorlanish. YAML profiles uchun yaxshiroq. Environment-specific configurationlar uchun application-{profile}.properties/yml ishlatiladi. Spring Boot ikkala formatni qo'llab-quvvatlaydi.",
    example: "# application.properties\nserver.port=8080\nspring.datasource.url=jdbc:mysql://localhost/mydb\nspring.datasource.username=root\nspring.datasource.password=password\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.show-sql=true\n\n# application.yml (bir xil konfiguratsiya)\nserver:\n  port: 8080\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost/mydb\n    username: root\n    password: password\n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n\n# Profile-specific\n# application-dev.properties\nserver.port=8081\n\n# application-prod.yml\nserver:\n  port: 80"
  },
  {
    id: 60,
    category: "Spring Boot (Junior)",
    question: "Spring Boot Starters nima va nima uchun kerak?",
    answer: "Spring Boot Starters - bu oldindan konfiguratsiya qilingan dependency descriptor lar to'plami. Bir starter qo'shish bilan barcha kerakli dependency lar avtomatik qo'shiladi. Masalan, spring-boot-starter-web qo'shilsa, Spring MVC, Tomcat, Jackson va boshqa kerakli library lar avtomatik kelib qo'shiladi. Bu dependency management ni osonlashtiradi va version conflict larini kamaytiradi. Har bir texnologiya uchun alohida starter mavjud.",
    example: "// Web application\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n// JPA\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n\n// Security\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\n// Test\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n\n// Validation\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-validation</artifactId>\n</dependency>"
  },
  {
    id: 61,
    category: "Spring Boot (Junior)",
    question: "Spring Boot Actuator nima va qanday ishlatiladi?",
    answer: "Spring Boot Actuator - production-ready features (monitoring, metrics, health checks) ni taqdim etadi. HTTP endpoints orqali application holatini tekshirish mumkin. /actuator/health - application health. /actuator/metrics - application metrics. /actuator/info - application info. /actuator/env - environment properties. /actuator/loggers - logging configuration. Spring Security bilan himoyalash kerak. Micrometer integration orqali monitoring system lar bilan integratsiya qilish mumkin.",
    example: "// Dependency qo'shish\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n\n// application.yml - endpointlarni yoqish\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,metrics,env\n  endpoint:\n    health:\n      show-details: always\n\ninfo:\n  app:\n    name: My Application\n    version: 1.0.0\n\n// Custom Health Indicator\n@Component\npublic class CustomHealthIndicator implements HealthIndicator {\n    @Override\n    public Health health() {\n        // Custom health check logic\n        boolean healthy = checkHealth();\n        if (healthy) {\n            return Health.up().withDetail(\"status\", \"Running\").build();\n        }\n        return Health.down().withDetail(\"error\", \"Not available\").build();\n    }\n}"
  },
  {
    id: 62,
    category: "Spring Boot (Junior)",
    question: "Spring Boot Profiles qanday ishlaydi va nima uchun kerak?",
    answer: "Profiles - environment-specific (dev, test, prod) konfiguratsiyalarni boshqarish uchun ishlatiladi. Har bir environment uchun alohida configuration file yaratish mumkin: application-{profile}.properties. Profileni faollashtirish: 1) application.properties da spring.profiles.active. 2) Command line argument: --spring.profiles.active=dev. 3) Environment variable. @Profile annotation bilan bean larni profile-specific qilish mumkin. Multiple profiles birga ishlatish mumkin.",
    example: "// application.properties (default)\nspring.profiles.active=dev\n\n// application-dev.properties\nserver.port=8080\nspring.datasource.url=jdbc:h2:mem:testdb\nlogging.level.root=DEBUG\n\n// application-prod.properties\nserver.port=80\nspring.datasource.url=jdbc:mysql://prod-server/mydb\nlogging.level.root=WARN\n\n// Profile-specific bean\n@Configuration\n@Profile(\"dev\")\npublic class DevConfiguration {\n    @Bean\n    public DataSource devDataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n}\n\n@Configuration\n@Profile(\"prod\")\npublic class ProdConfiguration {\n    @Bean\n    public DataSource prodDataSource() {\n        // Production DataSource\n    }\n}\n\n// Command line\njava -jar myapp.jar --spring.profiles.active=prod"
  },

  // Spring MVC (Middle)
  {
    id: 63,
    category: "Spring MVC (Middle)",
    question: "Spring MVC architecture qanday ishlaydi?",
    answer: "Spring MVC - Model-View-Controller pattern asosida qurilgan web framework. Request flow: 1) DispatcherServlet - front controller, barcha requestlarni qabul qiladi. 2) Handler Mapping - qaysi controller handle qilishini aniqlaydi. 3) Controller - request ni process qiladi va model qaytaradi. 4) ViewResolver - view nomini real view ga resolve qiladi. 5) View - response render qiladi. @Controller va @RestController annotation lar ishlatiladi. RESTful API uchun @RestController va @ResponseBody ishlatiladi.",
    example: "// Controller\n@Controller\npublic class UserController {\n    \n    @GetMapping(\"/users\")\n    public String getUsers(Model model) {\n        List<User> users = userService.findAll();\n        model.addAttribute(\"users\", users);\n        return \"users\"; // view name\n    }\n}\n\n// REST Controller\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserRestController {\n    \n    @Autowired\n    private UserService userService;\n    \n    @GetMapping\n    public List<User> getUsers() {\n        return userService.findAll(); // JSON qaytaradi\n    }\n    \n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n    \n    @PostMapping\n    public User createUser(@RequestBody User user) {\n        return userService.save(user);\n    }\n}"
  },
  {
    id: 64,
    category: "Spring MVC (Middle)",
    question: "@RequestMapping, @GetMapping, @PostMapping va boshqa mapping annotationlar qanday ishlaydi?",
    answer: "@RequestMapping - generic HTTP request mapping annotation, method type ko'rsatilishi kerak. @GetMapping - GET request uchun shortcut (@RequestMapping(method = RequestMethod.GET)). @PostMapping - POST request uchun. @PutMapping - PUT request uchun. @DeleteMapping - DELETE request uchun. @PatchMapping - PATCH request uchun. Path variable, request param, request body va headers bilan ishlash mumkin. Multiple URL pattern va content-type ni support qiladi.",
    example: "// Generic RequestMapping\n@RequestMapping(value = \"/users\", method = RequestMethod.GET)\npublic List<User> getUsers() { }\n\n// Shortcut annotations\n@GetMapping(\"/users\")\npublic List<User> getUsers() { }\n\n@PostMapping(\"/users\")\npublic User createUser(@RequestBody User user) { }\n\n@PutMapping(\"/users/{id}\")\npublic User updateUser(@PathVariable Long id, @RequestBody User user) { }\n\n@DeleteMapping(\"/users/{id}\")\npublic void deleteUser(@PathVariable Long id) { }\n\n// Multiple paths\n@GetMapping({\"/users\", \"/all-users\"})\npublic List<User> getUsers() { }\n\n// Path variable\n@GetMapping(\"/users/{id}/posts/{postId}\")\npublic Post getPost(@PathVariable Long id, @PathVariable Long postId) { }\n\n// Request params\n@GetMapping(\"/users\")\npublic List<User> searchUsers(\n    @RequestParam(required = false) String name,\n    @RequestParam(defaultValue = \"0\") int page\n) { }\n\n// Headers\n@GetMapping(value = \"/users\", headers = \"X-API-VERSION=1\")\npublic List<User> getUsersV1() { }"
  },
  {
    id: 65,
    category: "Spring MVC (Middle)",
    question: "Exception Handling in Spring MVC qanday amalga oshiriladi?",
    answer: "Spring MVC da exception handling uchun bir nechta usullar mavjud: 1) @ExceptionHandler - controller ichida specific exception lar uchun. 2) @ControllerAdvice/@RestControllerAdvice - global exception handling uchun. 3) ResponseEntityExceptionHandler - built-in exception handler. 4) Custom error attributes. @ExceptionHandler metod exception catch qiladi va custom response qaytaradi. HTTP status code, error message va boshqa ma'lumotlar yuborish mumkin.",
    example: "// Controller ichida\n@RestController\npublic class UserController {\n    \n    @GetMapping(\"/users/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id)\n            .orElseThrow(() -> new UserNotFoundException(id));\n    }\n    \n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\"User not found\", ex.getMessage());\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n}\n\n// Global exception handler\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.INTERNAL_SERVER_ERROR.value(),\n            \"Internal server error\",\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);\n    }\n}\n\n// Custom exception\npublic class UserNotFoundException extends RuntimeException {\n    public UserNotFoundException(Long id) {\n        super(\"User not found with id: \" + id);\n    }\n}"
  },
  {
    id: 66,
    category: "Spring MVC (Middle)",
    question: "Validation in Spring MVC qanday ishlaydi?",
    answer: "Spring MVC validation uchun JSR-303/JSR-380 (Bean Validation) dan foydalanadi. @Valid yoki @Validated annotation bilan validatsiya qilinadi. Hibernate Validator default implementation. BindingResult yoki MethodArgumentNotValidException orqali validation errorlarni handle qilish mumkin. Custom validator yaratish mumkin. Request body, path variable va request param validatsiya qilish mumkin. @NotNull, @NotEmpty, @Size, @Email, @Min, @Max va boshqa annotation lar mavjud.",
    example: "// Entity/DTO validation\npublic class UserDTO {\n    @NotNull(message = \"Name cannot be null\")\n    @NotEmpty(message = \"Name cannot be empty\")\n    @Size(min = 2, max = 50, message = \"Name must be between 2 and 50 characters\")\n    private String name;\n    \n    @Email(message = \"Email should be valid\")\n    private String email;\n    \n    @Min(value = 18, message = \"Age must be at least 18\")\n    @Max(value = 100, message = \"Age must be less than 100\")\n    private Integer age;\n}\n\n// Controller\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @PostMapping\n    public ResponseEntity<User> createUser(@Valid @RequestBody UserDTO userDTO) {\n        User user = userService.create(userDTO);\n        return ResponseEntity.ok(user);\n    }\n}\n\n// Exception handler\n@RestControllerAdvice\npublic class ValidationExceptionHandler {\n    \n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<Map<String, String>> handleValidationErrors(\n            MethodArgumentNotValidException ex) {\n        Map<String, String> errors = new HashMap<>();\n        ex.getBindingResult().getFieldErrors().forEach(error -> \n            errors.put(error.getField(), error.getDefaultMessage())\n        );\n        return ResponseEntity.badRequest().body(errors);\n    }\n}\n\n// Custom validator\n@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = AgeValidator.class)\npublic @interface ValidAge {\n    String message() default \"Invalid age\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n}"
  },
  {
    id: 67,
    category: "Spring MVC (Middle)",
    question: "Content Negotiation in Spring MVC qanday ishlaydi?",
    answer: "Content Negotiation - client qaysi format (JSON, XML, etc.) ni xohlashini aniqlash va shu formatda response qaytarish mexanizmi. Spring MVC Accept header, URL extension yoki query parameter orqali content type ni aniqlaydi. Jackson (JSON) va JAXB (XML) default converter lar. @RequestMapping da produces va consumes attribute lar bilan content type ni cheklash mumkin. Custom message converter yaratish mumkin.",
    example: "// Accept header bilan\n// Request: GET /api/users\n// Header: Accept: application/json\n// Response: JSON format\n\n// Request: GET /api/users\n// Header: Accept: application/xml\n// Response: XML format\n\n// Controller\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    // Faqat JSON accept qiladi\n    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)\n    public List<User> getUsersJson() {\n        return userService.findAll();\n    }\n    \n    // Faqat XML accept qiladi\n    @GetMapping(produces = MediaType.APPLICATION_XML_VALUE)\n    public List<User> getUsersXml() {\n        return userService.findAll();\n    }\n    \n    // JSON yoki XML\n    @GetMapping(produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})\n    public List<User> getUsers() {\n        return userService.findAll();\n    }\n    \n    // Request content type cheklash\n    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE)\n    public User createUser(@RequestBody User user) {\n        return userService.save(user);\n    }\n}\n\n// Configuration\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n        configurer\n            .favorParameter(true)\n            .parameterName(\"mediaType\")\n            .ignoreAcceptHeader(false)\n            .defaultContentType(MediaType.APPLICATION_JSON)\n            .mediaType(\"json\", MediaType.APPLICATION_JSON)\n            .mediaType(\"xml\", MediaType.APPLICATION_XML);\n    }\n}"
  },
  {
    id: 68,
    category: "Spring MVC (Middle)",
    question: "Interceptor va Filter o'rtasidagi farq nima va qanday ishlatiladi?",
    answer: "Filter - Servlet API ning bir qismi bo'lib, request dispatcher ga yetishdan oldin ishlaydi. Spring dan tashqarida ham ishlaydi. Interceptor - Spring MVC ning bir qismi bo'lib, handler mapping dan keyin va controller dan oldin ishlaydi. Spring context ga kirish imkoniyati bor. Interceptor da preHandle, postHandle va afterCompletion metodlari mavjud. Filter servletga yetishdan oldin, Interceptor controller ga yetishdan oldin ishlaydi. Authentication, logging, request modification uchun ishlatiladi.",
    example: "// Filter\n@Component\npublic class RequestLoggingFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, \n                         FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        System.out.println(\"Filter: \" + req.getRequestURI());\n        chain.doFilter(request, response);\n    }\n}\n\n// Interceptor\n@Component\npublic class RequestInterceptor implements HandlerInterceptor {\n    \n    @Override\n    public boolean preHandle(HttpServletRequest request, \n                             HttpServletResponse response, \n                             Object handler) throws Exception {\n        System.out.println(\"Interceptor preHandle: \" + request.getRequestURI());\n        // false qaytarsa, request davom etmaydi\n        return true;\n    }\n    \n    @Override\n    public void postHandle(HttpServletRequest request, \n                           HttpServletResponse response, \n                           Object handler, \n                           ModelAndView modelAndView) throws Exception {\n        System.out.println(\"Interceptor postHandle\");\n    }\n    \n    @Override\n    public void afterCompletion(HttpServletRequest request, \n                                HttpServletResponse response, \n                                Object handler, \n                                Exception ex) throws Exception {\n        System.out.println(\"Interceptor afterCompletion\");\n    }\n}\n\n// Interceptor registration\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    \n    @Autowired\n    private RequestInterceptor requestInterceptor;\n    \n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(requestInterceptor)\n            .addPathPatterns(\"/api/**\")\n            .excludePathPatterns(\"/api/public/**\");\n    }\n}"
  },

  // Spring Data JPA (Middle)
  {
    id: 69,
    category: "Spring Data JPA (Middle)",
    question: "Spring Data JPA nima va qanday ishlaydi?",
    answer: "Spring Data JPA - JPA (Java Persistence API) ni osonlashtiruvchi Spring modulli bo'lib, repository pattern ni implement qiladi. Hibernate default JPA provider. Interface yaratish orqali avtomatik CRUD operatsiyalarini ta'minlaydi. Query method naming convention orqali query yaratadi. @Query annotation bilan custom query yozish mumkin. CrudRepository, PagingAndSortingRepository, JpaRepository interface lari mavjud. Entity va Repository bilan ishlaydi.",
    example: "// Entity\n@Entity\n@Table(name = \"users\")\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(nullable = false)\n    private String name;\n    \n    @Column(unique = true)\n    private String email;\n    \n    private Integer age;\n}\n\n// Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // Query methods\n    List<User> findByName(String name);\n    List<User> findByAgeGreaterThan(Integer age);\n    Optional<User> findByEmail(String email);\n    List<User> findByNameContaining(String keyword);\n    \n    // Custom query\n    @Query(\"SELECT u FROM User u WHERE u.age >= :minAge\")\n    List<User> findUsersOlderThan(@Param(\"minAge\") Integer minAge);\n    \n    // Native query\n    @Query(value = \"SELECT * FROM users WHERE email LIKE %:domain\", nativeQuery = true)\n    List<User> findByEmailDomain(@Param(\"domain\") String domain);\n}\n\n// Service\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n    \n    public List<User> findAll() {\n        return userRepository.findAll();\n    }\n    \n    public User save(User user) {\n        return userRepository.save(user);\n    }\n}"
  },
  {
    id: 70,
    category: "Spring Data JPA (Middle)",
    question: "JPA Relationship mapping (OneToOne, OneToMany, ManyToMany) qanday ishlaydi?",
    answer: "@OneToOne - ikkita entity o'rtasida 1:1 relationship. @OneToMany - bir entity ko'p boshqa entity ga bog'langan. @ManyToOne - ko'p entity bir entity ga bog'langan. @ManyToMany - ko'pdan-ko'pga relationship (junction table). mappedBy - inverse side ni ko'rsatadi. Cascade operations - parent operation ni child ga o'tkazish. FetchType.LAZY va EAGER - ma'lumotlarni yuklash strategiyasi. Orphan removal - parent o'chirilsa, child ham o'chiriladi.",
    example: "// OneToOne\n@Entity\npublic class User {\n    @Id\n    @GeneratedValue\n    private Long id;\n    \n    @OneToOne(cascade = CascadeType.ALL)\n    @JoinColumn(name = \"profile_id\")\n    private UserProfile profile;\n}\n\n// OneToMany\n@Entity\npublic class Author {\n    @Id\n    @GeneratedValue\n    private Long id;\n    \n    @OneToMany(mappedBy = \"author\", cascade = CascadeType.ALL, orphanRemoval = true)\n    private List<Book> books = new ArrayList<>();\n}\n\n// ManyToOne\n@Entity\npublic class Book {\n    @Id\n    @GeneratedValue\n    private Long id;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"author_id\")\n    private Author author;\n}\n\n// ManyToMany\n@Entity\npublic class Student {\n    @Id\n    @GeneratedValue\n    private Long id;\n    \n    @ManyToMany\n    @JoinTable(\n        name = \"student_course\",\n        joinColumns = @JoinColumn(name = \"student_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"course_id\")\n    )\n    private Set<Course> courses = new HashSet<>();\n}\n\n@Entity\npublic class Course {\n    @Id\n    @GeneratedValue\n    private Long id;\n    \n    @ManyToMany(mappedBy = \"courses\")\n    private Set<Student> students = new HashSet<>();\n}"
  },
  {
    id: 71,
    category: "Spring Data JPA (Middle)",
    question: "@Transactional annotation qanday ishlaydi va nima uchun kerak?",
    answer: "@Transactional - transaction boshqaruvini ta'minlaydi. Metod yoki klass darajasida ishlatiladi. ACID properties ni ta'minlaydi. Transaction boshlanadi, commit yoki rollback qilinadi. Exception yuzaga kelsa, rollback amalga oshiriladi. Propagation - transaction qanday tarqalishi (REQUIRED, REQUIRES_NEW, NESTED). Isolation - transaction isolation darajasi. ReadOnly - performance uchun. Timeout - maksimal vaqt. rollbackFor - qaysi exception larda rollback.",
    example: "// Service layer da @Transactional\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Autowired\n    private OrderRepository orderRepository;\n    \n    // Default transaction\n    @Transactional\n    public User createUser(User user) {\n        return userRepository.save(user);\n    }\n    \n    // ReadOnly transaction\n    @Transactional(readOnly = true)\n    public List<User> findAll() {\n        return userRepository.findAll();\n    }\n    \n    // Complex transaction\n    @Transactional(\n        propagation = Propagation.REQUIRED,\n        isolation = Isolation.READ_COMMITTED,\n        timeout = 30,\n        rollbackFor = Exception.class\n    )\n    public void processOrder(Order order) {\n        User user = userRepository.findById(order.getUserId())\n            .orElseThrow(() -> new UserNotFoundException());\n        \n        // Agar bu yerda exception yuzaga kelsa, rollback bo'ladi\n        orderRepository.save(order);\n        user.setOrderCount(user.getOrderCount() + 1);\n        userRepository.save(user);\n    }\n    \n    // REQUIRES_NEW - yangi transaction\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void createLog(String message) {\n        // Bu metod alohida transactionda ishlaydi\n    }\n}\n\n// Class level\n@Service\n@Transactional\npublic class UserService {\n    // Barcha metodlar transactional\n}"
  },
  {
    id: 72,
    category: "Spring Data JPA (Middle)",
    question: "Lazy Loading va Eager Loading farqi nima va N+1 problem qanday yechiladi?",
    answer: "Lazy Loading - ma'lumotlar faqat kerak bo'lganda yuklanadi (FetchType.LAZY). Memory efficient, lekin LazyInitializationException xavfi. Eager Loading - ma'lumotlar darhol yuklanadi (FetchType.EAGER). Oddiy, lekin ko'p ma'lumot yuklaydi. N+1 problem - parent entity uchun 1 query, har bir child uchun alohida query (N ta). Yechimlar: 1) JOIN FETCH query. 2) @EntityGraph. 3) Batch fetching. 4) DTO projection. Default: @OneToMany/@ManyToMany - LAZY, @ManyToOne/@OneToOne - EAGER.",
    example: "// N+1 problem misoli\n@Entity\npublic class Author {\n    @Id\n    private Long id;\n    \n    @OneToMany(mappedBy = \"author\", fetch = FetchType.LAZY)\n    private List<Book> books;\n}\n\n// Muammo\nList<Author> authors = authorRepository.findAll(); // 1 query\nfor (Author author : authors) {\n    List<Book> books = author.getBooks(); // N ta query!\n}\n\n// Yechim 1: JOIN FETCH\n@Query(\"SELECT a FROM Author a JOIN FETCH a.books\")\nList<Author> findAllWithBooks();\n\n// Yechim 2: @EntityGraph\n@EntityGraph(attributePaths = {\"books\"})\n@Query(\"SELECT a FROM Author a\")\nList<Author> findAllWithBooksGraph();\n\n// Yechim 3: DTO Projection\n@Query(\"SELECT new com.example.dto.AuthorDTO(a.id, a.name, b.title) \" +\n       \"FROM Author a JOIN a.books b\")\nList<AuthorDTO> findAllAuthorsWithBooks();\n\n// Batch fetching\n@Entity\npublic class Author {\n    @OneToMany(mappedBy = \"author\", fetch = FetchType.LAZY)\n    @BatchSize(size = 10)\n    private List<Book> books;\n}\n\n// application.properties\nspring.jpa.properties.hibernate.default_batch_fetch_size=10"
  },
  {
    id: 73,
    category: "Spring Data JPA (Middle)",
    question: "Specification API va Custom Repository qanday ishlatiladi?",
    answer: "Specification API - dynamic query yaratish uchun ishlatiladi. Criteria API asosida qurilgan. JpaSpecificationExecutor interfeysi dan extend qilish kerak. Predicate orqali complex query lar yaratiladi. And, Or, Equal, Like, GreaterThan va boshqa operatorlar mavjud. Custom Repository - JPA repository ga qo'shimcha metod qo'shish uchun. Custom interface va implementation yaratiladi. Native query, stored procedure chaqirish mumkin.",
    example: "// Specification\npublic class UserSpecification {\n    \n    public static Specification<User> hasName(String name) {\n        return (root, query, cb) -> \n            name == null ? null : cb.equal(root.get(\"name\"), name);\n    }\n    \n    public static Specification<User> ageGreaterThan(Integer age) {\n        return (root, query, cb) -> \n            age == null ? null : cb.greaterThan(root.get(\"age\"), age);\n    }\n    \n    public static Specification<User> emailContains(String keyword) {\n        return (root, query, cb) -> \n            keyword == null ? null : cb.like(root.get(\"email\"), \"%\" + keyword + \"%\");\n    }\n}\n\n// Repository\npublic interface UserRepository extends JpaRepository<User, Long>, \n                                        JpaSpecificationExecutor<User> {\n}\n\n// Service\n@Service\npublic class UserService {\n    \n    public List<User> searchUsers(String name, Integer minAge, String emailKeyword) {\n        Specification<User> spec = Specification\n            .where(UserSpecification.hasName(name))\n            .and(UserSpecification.ageGreaterThan(minAge))\n            .and(UserSpecification.emailContains(emailKeyword));\n        \n        return userRepository.findAll(spec);\n    }\n}\n\n// Custom Repository\npublic interface CustomUserRepository {\n    List<User> findUsersWithCustomLogic();\n}\n\npublic class CustomUserRepositoryImpl implements CustomUserRepository {\n    \n    @PersistenceContext\n    private EntityManager entityManager;\n    \n    @Override\n    public List<User> findUsersWithCustomLogic() {\n        String sql = \"SELECT * FROM users WHERE ...\";\n        Query query = entityManager.createNativeQuery(sql, User.class);\n        return query.getResultList();\n    }\n}\n\n// Main repository\npublic interface UserRepository extends JpaRepository<User, Long>, \n                                        CustomUserRepository {\n}"
  },
  {
    id: 74,
    category: "Spring Data JPA (Middle)",
    question: "Pagination va Sorting qanday implement qilinadi?",
    answer: "Spring Data JPA Pageable va Sort interfeyslari orqali pagination va sorting ni qo'llab-quvvatlaydi. PagingAndSortingRepository yoki JpaRepository dan extend qilish kerak. PageRequest orqali page number, size va sort yo'nalishi belgilanadi. Page<T> yoki Slice<T> qaytaradi. Page - total elementlar soni va pages soni. Slice - faqat keyingi page bor-yo'qligi. @PageableDefault annotation bilan default qiymatlar berish mumkin.",
    example: "// Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    Page<User> findByNameContaining(String name, Pageable pageable);\n    Page<User> findByAgeGreaterThan(Integer age, Pageable pageable);\n}\n\n// Controller\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @GetMapping\n    public Page<User> getUsers(\n            @RequestParam(defaultValue = \"0\") int page,\n            @RequestParam(defaultValue = \"10\") int size,\n            @RequestParam(defaultValue = \"id\") String sortBy,\n            @RequestParam(defaultValue = \"asc\") String direction) {\n        \n        Sort sort = direction.equalsIgnoreCase(\"asc\") \n            ? Sort.by(sortBy).ascending() \n            : Sort.by(sortBy).descending();\n        \n        Pageable pageable = PageRequest.of(page, size, sort);\n        return userRepository.findAll(pageable);\n    }\n    \n    // Spring auto-binding\n    @GetMapping(\"/auto\")\n    public Page<User> getUsersAuto(\n            @PageableDefault(size = 20, sort = \"name\") Pageable pageable) {\n        return userRepository.findAll(pageable);\n    }\n    \n    // Multiple sorting\n    @GetMapping(\"/multi-sort\")\n    public Page<User> getUsersMultiSort() {\n        Sort sort = Sort.by(\"age\").descending().and(Sort.by(\"name\").ascending());\n        Pageable pageable = PageRequest.of(0, 10, sort);\n        return userRepository.findAll(pageable);\n    }\n}\n\n// URL: /api/users?page=0&size=10&sortBy=name&direction=desc"
  },

  // Spring Security (Senior)
  {
    id: 75,
    category: "Spring Security (Senior)",
    question: "Spring Security architecture qanday ishlaydi?",
    answer: "Spring Security - authentication va authorization uchun comprehensive framework. Filter chain asosida qurilgan. SecurityFilterChain - bir nechta filterlardan iborat. Authentication - foydalanuvchini aniqlash. Authorization - foydalanuvchining huquqlarini tekshirish. SecurityContext - authentication ma'lumotlarini saqlaydi. UserDetailsService - foydalanuvchi ma'lumotlarini yuklaydi. PasswordEncoder - parollarni encode qiladi. JWT, OAuth2, LDAP, database authentication qo'llab-quvvatlanadi.",
    example: "// Security Configuration\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .csrf().disable()\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .requestMatchers(\"/api/user/**\").hasAnyRole(\"USER\", \"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .httpBasic()\n            .and()\n            .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        \n        return http.build();\n    }\n    \n    @Bean\n    public UserDetailsService userDetailsService() {\n        UserDetails user = User.builder()\n            .username(\"user\")\n            .password(passwordEncoder().encode(\"password\"))\n            .roles(\"USER\")\n            .build();\n        \n        UserDetails admin = User.builder()\n            .username(\"admin\")\n            .password(passwordEncoder().encode(\"admin\"))\n            .roles(\"ADMIN\")\n            .build();\n        \n        return new InMemoryUserDetailsManager(user, admin);\n    }\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}"
  },
  {
    id: 76,
    category: "Spring Security (Senior)",
    question: "JWT (JSON Web Token) authentication qanday implement qilinadi?",
    answer: "JWT - stateless authentication uchun ishlatiladi. Token 3 qismdan iborat: Header, Payload, Signature. Token generate qilinadi va client ga yuboriladi. Client har safar request da token yuboradi. Server token ni validate qiladi va user ma'lumotlarini oladi. Access token (qisqa umr) va Refresh token (uzoq umr) ishlatiladi. JwtAuthenticationFilter yaratish kerak. TokenProvider yoki JwtUtil service yaratish kerak. Secret key bilan sign qilinadi.",
    example: "// JwtUtil Service\n@Service\npublic class JwtUtil {\n    \n    @Value(\"${jwt.secret}\")\n    private String secret;\n    \n    @Value(\"${jwt.expiration}\")\n    private Long expiration;\n    \n    public String generateToken(UserDetails userDetails) {\n        Map<String, Object> claims = new HashMap<>();\n        return Jwts.builder()\n            .setClaims(claims)\n            .setSubject(userDetails.getUsername())\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(System.currentTimeMillis() + expiration))\n            .signWith(SignatureAlgorithm.HS512, secret)\n            .compact();\n    }\n    \n    public String getUsernameFromToken(String token) {\n        return Jwts.parser()\n            .setSigningKey(secret)\n            .parseClaimsJws(token)\n            .getBody()\n            .getSubject();\n    }\n    \n    public boolean validateToken(String token, UserDetails userDetails) {\n        String username = getUsernameFromToken(token);\n        return username.equals(userDetails.getUsername()) && !isTokenExpired(token);\n    }\n    \n    private boolean isTokenExpired(String token) {\n        Date expiration = Jwts.parser()\n            .setSigningKey(secret)\n            .parseClaimsJws(token)\n            .getBody()\n            .getExpiration();\n        return expiration.before(new Date());\n    }\n}\n\n// JWT Filter\n@Component\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n    \n    @Autowired\n    private JwtUtil jwtUtil;\n    \n    @Autowired\n    private UserDetailsService userDetailsService;\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request, \n                                    HttpServletResponse response, \n                                    FilterChain chain) throws ServletException, IOException {\n        \n        String header = request.getHeader(\"Authorization\");\n        String token = null;\n        String username = null;\n        \n        if (header != null && header.startsWith(\"Bearer \")) {\n            token = header.substring(7);\n            username = jwtUtil.getUsernameFromToken(token);\n        }\n        \n        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\n            UserDetails userDetails = userDetailsService.loadUserByUsername(username);\n            \n            if (jwtUtil.validateToken(token, userDetails)) {\n                UsernamePasswordAuthenticationToken authentication = \n                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\n                SecurityContextHolder.getContext().setAuthentication(authentication);\n            }\n        }\n        \n        chain.doFilter(request, response);\n    }\n}\n\n// Security Config\n@Configuration\npublic class SecurityConfig {\n    \n    @Autowired\n    private JwtAuthenticationFilter jwtFilter;\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .csrf().disable()\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/auth/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n        \n        return http.build();\n    }\n}\n\n// Auth Controller\n@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n    \n    @Autowired\n    private AuthenticationManager authenticationManager;\n    \n    @Autowired\n    private JwtUtil jwtUtil;\n    \n    @Autowired\n    private UserDetailsService userDetailsService;\n    \n    @PostMapping(\"/login\")\n    public ResponseEntity<AuthResponse> login(@RequestBody LoginRequest request) {\n        Authentication authentication = authenticationManager.authenticate(\n            new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())\n        );\n        \n        UserDetails userDetails = userDetailsService.loadUserByUsername(request.getUsername());\n        String token = jwtUtil.generateToken(userDetails);\n        \n        return ResponseEntity.ok(new AuthResponse(token));\n    }\n}"
  },
  {
    id: 77,
    category: "Spring Security (Senior)",
    question: "Method Security va @PreAuthorize, @PostAuthorize qanday ishlaydi?",
    answer: "Method Security - metod darajasida authorization. @EnableGlobalMethodSecurity annotation bilan yoqiladi. @PreAuthorize - metod chaqirilishidan oldin tekshiradi. @PostAuthorize - metod return qilgandan keyin tekshiradi. @Secured - oddiy role checking. @RolesAllowed - JSR-250 annotation. SpEL (Spring Expression Language) dan foydalanadi. hasRole(), hasAuthority(), principal, authentication obyektlariga kirish mumkin. Custom security expression yaratish mumkin.",
    example: "// Enable Method Security\n@Configuration\n@EnableGlobalMethodSecurity(\n    prePostEnabled = true,\n    securedEnabled = true,\n    jsr250Enabled = true\n)\npublic class MethodSecurityConfig { }\n\n// Service\n@Service\npublic class UserService {\n    \n    // Only ADMIN can call this\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    // User can only get their own data\n    @PreAuthorize(\"#userId == authentication.principal.id\")\n    public User getUser(Long userId) {\n        return userRepository.findById(userId).orElseThrow();\n    }\n    \n    // Multiple conditions\n    @PreAuthorize(\"hasRole('ADMIN') or #userId == authentication.principal.id\")\n    public void updateUser(Long userId, User user) {\n        userRepository.save(user);\n    }\n    \n    // PostAuthorize - check return value\n    @PostAuthorize(\"returnObject.username == authentication.principal.username\")\n    public User getUserDetails(Long id) {\n        return userRepository.findById(id).orElseThrow();\n    }\n    \n    // @Secured annotation\n    @Secured({\"ROLE_ADMIN\", \"ROLE_MANAGER\"})\n    public void deleteUser(Long id) {\n        userRepository.deleteById(id);\n    }\n    \n    // JSR-250 @RolesAllowed\n    @RolesAllowed(\"ADMIN\")\n    public void adminOperation() { }\n}\n\n// Custom Security Expression\n@Component(\"customSecurity\")\npublic class CustomSecurityExpression {\n    \n    public boolean canAccessUser(Long userId) {\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        UserDetails user = (UserDetails) auth.getPrincipal();\n        // Custom logic\n        return true;\n    }\n}\n\n// Usage\n@PreAuthorize(\"@customSecurity.canAccessUser(#userId)\")\npublic User getUser(Long userId) { }"
  },
  {
    id: 78,
    category: "Spring Security (Senior)",
    question: "OAuth2 va Spring Security qanday integratsiya qilinadi?",
    answer: "OAuth2 - authorization framework bo'lib, uchinchi tomon access berish uchun ishlatiladi. Resource Owner, Resource Server, Authorization Server, Client rollari mavjud. Authorization Code, Implicit, Resource Owner Password, Client Credentials grant type lari bor. Spring Security OAuth2 Client va Resource Server ni qo'llab-quvvatlaydi. Google, Facebook, GitHub kabi OAuth2 provider lar bilan integratsiya oson. JWT token lar ishlatiladi. spring-boot-starter-oauth2-client va spring-boot-starter-oauth2-resource-server dependency lar kerak.",
    example: "// OAuth2 Client Configuration\n// application.yml\nspring:\n  security:\n    oauth2:\n      client:\n        registration:\n          google:\n            client-id: your-client-id\n            client-secret: your-client-secret\n            scope: profile, email\n          github:\n            client-id: your-github-client-id\n            client-secret: your-github-client-secret\n            scope: read:user, user:email\n        provider:\n          google:\n            authorization-uri: https://accounts.google.com/o/oauth2/v2/auth\n            token-uri: https://oauth2.googleapis.com/token\n            user-info-uri: https://www.googleapis.com/oauth2/v3/userinfo\n\n// Security Config\n@Configuration\npublic class OAuth2SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/\", \"/login\", \"/error\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2Login(oauth2 -> oauth2\n                .loginPage(\"/login\")\n                .defaultSuccessUrl(\"/dashboard\")\n                .failureUrl(\"/login?error=true\")\n            );\n        \n        return http.build();\n    }\n}\n\n// Controller\n@RestController\npublic class OAuth2Controller {\n    \n    @GetMapping(\"/user\")\n    public Map<String, Object> user(@AuthenticationPrincipal OAuth2User principal) {\n        return Collections.singletonMap(\"name\", principal.getAttribute(\"name\"));\n    }\n}\n\n// Resource Server Configuration\n@Configuration\n@EnableResourceServer\npublic class ResourceServerConfig {\n    \n    @Bean\n    public SecurityFilterChain resourceServerFilterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2\n                .jwt(jwt -> jwt\n                    .jwtAuthenticationConverter(jwtAuthenticationConverter())\n                )\n            );\n        \n        return http.build();\n    }\n    \n    @Bean\n    public JwtAuthenticationConverter jwtAuthenticationConverter() {\n        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = \n            new JwtGrantedAuthoritiesConverter();\n        grantedAuthoritiesConverter.setAuthorityPrefix(\"ROLE_\");\n        \n        JwtAuthenticationConverter jwtAuthenticationConverter = \n            new JwtAuthenticationConverter();\n        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(\n            grantedAuthoritiesConverter);\n        \n        return jwtAuthenticationConverter;\n    }\n}\n\n// application.yml - Resource Server\nspring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          issuer-uri: https://your-auth-server.com\n          jwk-set-uri: https://your-auth-server.com/.well-known/jwks.json"
  },
  {
    id: 79,
    category: "Spring Security (Senior)",
    question: "CORS va CSRF qanday configure qilinadi?",
    answer: "CORS (Cross-Origin Resource Sharing) - boshqa domaindan API ga request qilish uchun kerak. Browser security feature. @CrossOrigin annotation yoki global configuration. Preflight request (OPTIONS) uchun ham sozlash kerak. CSRF (Cross-Site Request Forgery) - zararli saytdan foydalanuvchi nomidan request yuborish. Spring Security default yoqilgan. Token-based himoya. Stateless API lar uchun o'chirish mumkin. SameSite cookie attribute ham yordam beradi.",
    example: "// CORS Configuration\n@Configuration\npublic class CorsConfig {\n    \n    @Bean\n    public WebMvcConfigurer corsConfigurer() {\n        return new WebMvcConfigurer() {\n            @Override\n            public void addCorsMappings(CorsRegistry registry) {\n                registry.addMapping(\"/api/**\")\n                    .allowedOrigins(\"http://localhost:3000\", \"https://mydomain.com\")\n                    .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\")\n                    .allowedHeaders(\"*\")\n                    .allowCredentials(true)\n                    .maxAge(3600);\n            }\n        };\n    }\n}\n\n// Controller level\n@RestController\n@RequestMapping(\"/api/users\")\n@CrossOrigin(origins = \"http://localhost:3000\")\npublic class UserController { }\n\n// Method level\n@CrossOrigin(origins = \"http://localhost:3000\", methods = RequestMethod.GET)\n@GetMapping(\"/users\")\npublic List<User> getUsers() { }\n\n// Security Config - CORS and CSRF\n@Configuration\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            // Enable CORS\n            .cors()\n            .and()\n            // Disable CSRF for stateless API\n            .csrf().disable()\n            // Or configure CSRF\n            .csrf(csrf -> csrf\n                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n                .ignoringRequestMatchers(\"/api/public/**\")\n            )\n            .authorizeHttpRequests(auth -> auth\n                .anyRequest().authenticated()\n            );\n        \n        return http.build();\n    }\n    \n    // CORS Configuration Source\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration configuration = new CorsConfiguration();\n        configuration.setAllowedOrigins(Arrays.asList(\"http://localhost:3000\"));\n        configuration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\", \"PUT\", \"DELETE\"));\n        configuration.setAllowedHeaders(Arrays.asList(\"*\"));\n        configuration.setAllowCredentials(true);\n        \n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/api/**\", configuration);\n        \n        return source;\n    }\n}\n\n// CSRF Token in Thymeleaf\n<form method=\"post\" action=\"/api/users\">\n    <input type=\"hidden\" th:name=\"${_csrf.parameterName}\" th:value=\"${_csrf.token}\"/>\n    <!-- form fields -->\n</form>\n\n// CSRF Token in JavaScript\nfetch('/api/users', {\n    method: 'POST',\n    headers: {\n        'X-CSRF-TOKEN': document.querySelector('meta[name=\"_csrf\"]').content\n    },\n    body: JSON.stringify(data)\n});"
  },
  {
    id: 80,
    category: "Spring Security (Senior)",
    question: "Custom Authentication Provider qanday yaratiladi?",
    answer: "Custom Authentication Provider - maxsus authentication logic uchun yaratiladi. AuthenticationProvider interfeysi dan extend qilinadi. authenticate() va supports() metodlarini implement qilish kerak. Custom UserDetailsService bilan birga ishlaydi. Database, LDAP, external API dan authentication qilish mumkin. Multiple authentication provider lar birga ishlashi mumkin. AuthenticationManager tomonidan boshqariladi. Custom exception handling qo'shish mumkin.",
    example: "// Custom Authentication Provider\n@Component\npublic class CustomAuthenticationProvider implements AuthenticationProvider {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Autowired\n    private PasswordEncoder passwordEncoder;\n    \n    @Override\n    public Authentication authenticate(Authentication authentication) \n            throws AuthenticationException {\n        \n        String username = authentication.getName();\n        String password = authentication.getCredentials().toString();\n        \n        // Custom authentication logic\n        User user = userRepository.findByUsername(username)\n            .orElseThrow(() -> new UsernameNotFoundException(\"User not found\"));\n        \n        if (!passwordEncoder.matches(password, user.getPassword())) {\n            throw new BadCredentialsException(\"Invalid password\");\n        }\n        \n        if (!user.isEnabled()) {\n            throw new DisabledException(\"User is disabled\");\n        }\n        \n        // Custom checks\n        if (user.getLoginAttempts() >= 5) {\n            throw new LockedException(\"Account locked due to multiple failed attempts\");\n        }\n        \n        // Create authorities\n        List<GrantedAuthority> authorities = user.getRoles().stream()\n            .map(role -> new SimpleGrantedAuthority(\"ROLE_\" + role.getName()))\n            .collect(Collectors.toList());\n        \n        return new UsernamePasswordAuthenticationToken(username, password, authorities);\n    }\n    \n    @Override\n    public boolean supports(Class<?> authentication) {\n        return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);\n    }\n}\n\n// Custom UserDetailsService\n@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        User user = userRepository.findByUsername(username)\n            .orElseThrow(() -> new UsernameNotFoundException(\"User not found: \" + username));\n        \n        return new org.springframework.security.core.userdetails.User(\n            user.getUsername(),\n            user.getPassword(),\n            user.isEnabled(),\n            true, // accountNonExpired\n            true, // credentialsNonExpired\n            true, // accountNonLocked\n            getAuthorities(user)\n        );\n    }\n    \n    private Collection<? extends GrantedAuthority> getAuthorities(User user) {\n        return user.getRoles().stream()\n            .map(role -> new SimpleGrantedAuthority(\"ROLE_\" + role.getName()))\n            .collect(Collectors.toList());\n    }\n}\n\n// Security Configuration\n@Configuration\npublic class SecurityConfig {\n    \n    @Autowired\n    private CustomAuthenticationProvider authProvider;\n    \n    @Bean\n    public AuthenticationManager authManager(HttpSecurity http) throws Exception {\n        AuthenticationManagerBuilder authenticationManagerBuilder = \n            http.getSharedObject(AuthenticationManagerBuilder.class);\n        authenticationManagerBuilder.authenticationProvider(authProvider);\n        return authenticationManagerBuilder.build();\n    }\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authenticationProvider(authProvider)\n            .authorizeHttpRequests(auth -> auth\n                .anyRequest().authenticated()\n            )\n            .formLogin();\n        \n        return http.build();\n    }\n}"
  },

  // Spring Advanced (Senior)
  {
    id: 81,
    category: "Spring Advanced (Senior)",
    question: "AOP (Aspect-Oriented Programming) nima va qanday ishlatiladi?",
    answer: "AOP - cross-cutting concernlarni (logging, security, transaction) asosiy business logic dan ajratish uchun ishlatiladi. Aspect - cross-cutting concern implementation. Join point - dastur execution ning nuqtasi. Pointcut - join pointlar to'plami. Advice - aspect qachon execute qilishi (Before, After, Around, AfterReturning, AfterThrowing). Weaving - aspect ni applicationga qo'shish. @Aspect annotation bilan yaratiladi. Spring AOP proxy-based (runtime). AspectJ compile-time weaving.",
    example: "// Aspect\n@Aspect\n@Component\npublic class LoggingAspect {\n    \n    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);\n    \n    // Pointcut - barcha service metodlari\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceMethods() {}\n    \n    // Before advice\n    @Before(\"serviceMethods()\")\n    public void logBefore(JoinPoint joinPoint) {\n        logger.info(\"Calling method: \" + joinPoint.getSignature().getName());\n    }\n    \n    // After advice\n    @After(\"serviceMethods()\")\n    public void logAfter(JoinPoint joinPoint) {\n        logger.info(\"Method completed: \" + joinPoint.getSignature().getName());\n    }\n    \n    // Around advice\n    @Around(\"serviceMethods()\")\n    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {\n        long start = System.currentTimeMillis();\n        \n        logger.info(\"Method started: \" + joinPoint.getSignature().getName());\n        \n        Object result = joinPoint.proceed(); // Execute method\n        \n        long executionTime = System.currentTimeMillis() - start;\n        logger.info(\"Method finished in \" + executionTime + \"ms\");\n        \n        return result;\n    }\n    \n    // AfterReturning - return qiymat bilan\n    @AfterReturning(pointcut = \"serviceMethods()\", returning = \"result\")\n    public void logAfterReturning(JoinPoint joinPoint, Object result) {\n        logger.info(\"Method returned: \" + result);\n    }\n    \n    // AfterThrowing - exception bilan\n    @AfterThrowing(pointcut = \"serviceMethods()\", throwing = \"error\")\n    public void logAfterThrowing(JoinPoint joinPoint, Throwable error) {\n        logger.error(\"Method threw exception: \" + error);\n    }\n}\n\n// Custom annotation aspect\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface LogExecutionTime { }\n\n@Aspect\n@Component\npublic class ExecutionTimeAspect {\n    \n    @Around(\"@annotation(LogExecutionTime)\")\n    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {\n        long start = System.currentTimeMillis();\n        Object result = joinPoint.proceed();\n        long executionTime = System.currentTimeMillis() - start;\n        System.out.println(joinPoint.getSignature() + \" executed in \" + executionTime + \"ms\");\n        return result;\n    }\n}\n\n// Usage\n@Service\npublic class UserService {\n    \n    @LogExecutionTime\n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n}\n\n// Enable AOP\n@Configuration\n@EnableAspectJAutoProxy\npublic class AopConfig { }"
  },
  {
    id: 82,
    category: "Spring Advanced (Senior)",
    question: "Caching in Spring qanday ishlaydi?",
    answer: "Spring Cache Abstraction - caching operatsiyalarini soddalashtiradi. @Cacheable - metod natijasini cache ga saqlaydi. @CachePut - cache ni update qiladi. @CacheEvict - cache ni tozalaydi. @Caching - multiple cache operatsiyalari. CacheManager - cache provider ni boshqaradi. Concurrent HashMap, EhCache, Redis, Hazelcast qo'llab-quvvatlanadi. SpEL bilan dynamic key generation. Conditional caching. Time-to-live (TTL) sozlanadi.",
    example: "// Enable Caching\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n    \n    @Bean\n    public CacheManager cacheManager() {\n        SimpleCacheManager cacheManager = new SimpleCacheManager();\n        cacheManager.setCaches(Arrays.asList(\n            new ConcurrentMapCache(\"users\"),\n            new ConcurrentMapCache(\"products\")\n        ));\n        return cacheManager;\n    }\n}\n\n// Service with caching\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    // Cache natija\n    @Cacheable(value = \"users\", key = \"#id\")\n    public User getUserById(Long id) {\n        System.out.println(\"Fetching from database...\");\n        return userRepository.findById(id).orElse(null);\n    }\n    \n    // Multiple cache names\n    @Cacheable(value = {\"users\", \"userCache\"}, key = \"#username\")\n    public User getUserByUsername(String username) {\n        return userRepository.findByUsername(username).orElse(null);\n    }\n    \n    // Conditional caching\n    @Cacheable(value = \"users\", key = \"#id\", condition = \"#id > 0\")\n    public User getUser(Long id) {\n        return userRepository.findById(id).orElse(null);\n    }\n    \n    // Cache update\n    @CachePut(value = \"users\", key = \"#user.id\")\n    public User updateUser(User user) {\n        return userRepository.save(user);\n    }\n    \n    // Cache eviction\n    @CacheEvict(value = \"users\", key = \"#id\")\n    public void deleteUser(Long id) {\n        userRepository.deleteById(id);\n    }\n    \n    // Evict all entries\n    @CacheEvict(value = \"users\", allEntries = true)\n    public void deleteAllUsers() {\n        userRepository.deleteAll();\n    }\n    \n    // Multiple cache operations\n    @Caching(\n        cacheable = @Cacheable(value = \"users\", key = \"#id\"),\n        put = @CachePut(value = \"userCache\", key = \"#result.username\"),\n        evict = @CacheEvict(value = \"oldUsers\", key = \"#id\")\n    )\n    public User complexCacheOperation(Long id) {\n        return userRepository.findById(id).orElse(null);\n    }\n}\n\n// Redis Cache Configuration\n@Configuration\n@EnableCaching\npublic class RedisCacheConfig {\n    \n    @Bean\n    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {\n        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\n            .entryTtl(Duration.ofMinutes(10))\n            .disableCachingNullValues();\n        \n        return RedisCacheManager.builder(connectionFactory)\n            .cacheDefaults(config)\n            .build();\n    }\n}"
  },
  {
    id: 83,
    category: "Spring Advanced (Senior)",
    question: "Event Handling in Spring qanday ishlaydi?",
    answer: "Spring Events - application ichida loosely coupled communication uchun ishlatiladi. ApplicationEvent - event lar uchun base class. ApplicationListener - event listener interface. @EventListener - annotation-based listener. ApplicationEventPublisher - event publish qilish uchun. Synchronous (default) va Asynchronous events. Custom event yaratish mumkin. Transaction-bound events (@TransactionalEventListener). SpEL bilan conditional event handling.",
    example: "// Custom Event\npublic class UserRegisteredEvent extends ApplicationEvent {\n    private User user;\n    \n    public UserRegisteredEvent(Object source, User user) {\n        super(source);\n        this.user = user;\n    }\n    \n    public User getUser() {\n        return user;\n    }\n}\n\n// Event Publisher (Service)\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Autowired\n    private ApplicationEventPublisher eventPublisher;\n    \n    public User registerUser(User user) {\n        User savedUser = userRepository.save(user);\n        \n        // Publish event\n        eventPublisher.publishEvent(new UserRegisteredEvent(this, savedUser));\n        \n        return savedUser;\n    }\n}\n\n// Event Listener\n@Component\npublic class UserEventListener {\n    \n    // Annotation-based listener\n    @EventListener\n    public void handleUserRegistered(UserRegisteredEvent event) {\n        User user = event.getUser();\n        System.out.println(\"User registered: \" + user.getUsername());\n        // Send welcome email, create profile, etc.\n    }\n    \n    // Conditional listener\n    @EventListener(condition = \"#event.user.age >= 18\")\n    public void handleAdultUserRegistered(UserRegisteredEvent event) {\n        System.out.println(\"Adult user registered\");\n    }\n    \n    // Asynchronous listener\n    @Async\n    @EventListener\n    public void handleAsyncEvent(UserRegisteredEvent event) {\n        // This runs in a separate thread\n        System.out.println(\"Async processing for: \" + event.getUser().getUsername());\n    }\n    \n    // Transactional event listener\n    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)\n    public void handleAfterCommit(UserRegisteredEvent event) {\n        // Executed after transaction commits\n        System.out.println(\"Transaction committed for: \" + event.getUser().getUsername());\n    }\n    \n    @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)\n    public void handleAfterRollback(UserRegisteredEvent event) {\n        System.out.println(\"Transaction rolled back\");\n    }\n}\n\n// Interface-based listener (old way)\n@Component\npublic class OldStyleListener implements ApplicationListener<UserRegisteredEvent> {\n    \n    @Override\n    public void onApplicationEvent(UserRegisteredEvent event) {\n        System.out.println(\"Old style listener: \" + event.getUser().getUsername());\n    }\n}\n\n// Enable async\n@Configuration\n@EnableAsync\npublic class AsyncConfig { }\n\n// Generic event\n@EventListener\npublic void handleAllEvents(ApplicationEvent event) {\n    System.out.println(\"Event received: \" + event.getClass().getSimpleName());\n}"
  },
  {
    id: 84,
    category: "Spring Advanced (Senior)",
    question: "WebSocket va Spring STOMP qanday ishlaydi?",
    answer: "WebSocket - full-duplex, real-time communication protocol. HTTP dan farqli ravishda ikki tomonlama aloqa. Spring WebSocket va STOMP (Simple Text Oriented Messaging Protocol) qo'llab-quvvatlaydi. SockJS - WebSocket mavjud bo'lmagan browserlar uchun fallback. Message broker (in-memory yoki external RabbitMQ, ActiveMQ). @MessageMapping - message handle qilish uchun. @SendTo - javob yuborish uchun. SimpMessagingTemplate - message yuborish uchun. Chat, notification, live updates uchun ishlatiladi.",
    example: "// WebSocket Configuration\n@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n    \n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        // Enable simple broker for in-memory messages\n        config.enableSimpleBroker(\"/topic\", \"/queue\");\n        // Application destination prefix\n        config.setApplicationDestinationPrefixes(\"/app\");\n    }\n    \n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        // Register STOMP endpoint\n        registry.addEndpoint(\"/ws\")\n            .setAllowedOrigins(\"*\")\n            .withSockJS(); // Enable SockJS fallback\n    }\n}\n\n// Message Model\npublic class ChatMessage {\n    private String content;\n    private String sender;\n    private MessageType type;\n    \n    public enum MessageType {\n        CHAT, JOIN, LEAVE\n    }\n}\n\n// WebSocket Controller\n@Controller\npublic class ChatController {\n    \n    @Autowired\n    private SimpMessagingTemplate messagingTemplate;\n    \n    // Receive message from client\n    @MessageMapping(\"/chat.sendMessage\")\n    @SendTo(\"/topic/public\")\n    public ChatMessage sendMessage(@Payload ChatMessage chatMessage) {\n        return chatMessage;\n    }\n    \n    @MessageMapping(\"/chat.addUser\")\n    @SendTo(\"/topic/public\")\n    public ChatMessage addUser(@Payload ChatMessage chatMessage, \n                               SimpMessageHeaderAccessor headerAccessor) {\n        // Add username in web socket session\n        headerAccessor.getSessionAttributes().put(\"username\", chatMessage.getSender());\n        return chatMessage;\n    }\n    \n    // Send message to specific user\n    public void sendToUser(String username, ChatMessage message) {\n        messagingTemplate.convertAndSendToUser(\n            username, \n            \"/queue/messages\", \n            message\n        );\n    }\n    \n    // Broadcast message\n    public void broadcastMessage(ChatMessage message) {\n        messagingTemplate.convertAndSend(\"/topic/public\", message);\n    }\n}\n\n// Event Listener\n@Component\npublic class WebSocketEventListener {\n    \n    @Autowired\n    private SimpMessageSendingOperations messagingTemplate;\n    \n    @EventListener\n    public void handleWebSocketConnectListener(SessionConnectedEvent event) {\n        System.out.println(\"New WebSocket connection\");\n    }\n    \n    @EventListener\n    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {\n        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());\n        String username = (String) headerAccessor.getSessionAttributes().get(\"username\");\n        \n        if(username != null) {\n            ChatMessage chatMessage = new ChatMessage();\n            chatMessage.setType(ChatMessage.MessageType.LEAVE);\n            chatMessage.setSender(username);\n            \n            messagingTemplate.convertAndSend(\"/topic/public\", chatMessage);\n        }\n    }\n}\n\n// JavaScript Client\nvar socket = new SockJS('/ws');\nvar stompClient = Stomp.over(socket);\n\nstompClient.connect({}, function(frame) {\n    console.log('Connected: ' + frame);\n    \n    // Subscribe to topic\n    stompClient.subscribe('/topic/public', function(message) {\n        var chatMessage = JSON.parse(message.body);\n        console.log(chatMessage);\n    });\n    \n    // Send message\n    stompClient.send(\"/app/chat.sendMessage\", {}, \n        JSON.stringify({content: 'Hello', sender: 'User'})\n    );\n});"
  },
  {
    id: 85,
    category: "Spring Advanced (Senior)",
    question: "Microservices architecture va Spring Cloud qanday ishlaydi?",
    answer: "Microservices - katta applicationni kichik, mustaqil servicelarga bo'lish. Har bir service o'z database ga ega. Spring Cloud - microservices pattern larini implement qilish uchun toolkit. Service Discovery (Eureka), API Gateway (Spring Cloud Gateway), Config Server (centralized configuration), Circuit Breaker (Resilience4j), Load Balancing (Spring Cloud LoadBalancer), Distributed Tracing (Sleuth, Zipkin). Inter-service communication - REST, gRPC, messaging. Containerization (Docker, Kubernetes).",
    example: "// 1. Service Registry (Eureka Server)\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n\n// application.yml\nserver:\n  port: 8761\neureka:\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n\n// 2. Microservice (Eureka Client)\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class UserServiceApplication { }\n\n// application.yml\nspring:\n  application:\n    name: user-service\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n\n// 3. API Gateway\n@SpringBootApplication\npublic class ApiGatewayApplication { }\n\n// application.yml\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: user-service\n          uri: lb://user-service\n          predicates:\n            - Path=/api/users/**\n          filters:\n            - StripPrefix=1\n        - id: order-service\n          uri: lb://order-service\n          predicates:\n            - Path=/api/orders/**\n\n// 4. Config Server\n@SpringBootApplication\n@EnableConfigServer\npublic class ConfigServerApplication { }\n\n// application.yml\nspring:\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://github.com/your-repo/config-repo\n\n// 5. Circuit Breaker (Resilience4j)\n@Service\npublic class UserService {\n    \n    @Autowired\n    private RestTemplate restTemplate;\n    \n    @CircuitBreaker(name = \"orderService\", fallbackMethod = \"getOrdersFallback\")\n    public List<Order> getOrders(Long userId) {\n        return restTemplate.getForObject(\n            \"http://order-service/api/orders/user/\" + userId,\n            List.class\n        );\n    }\n    \n    public List<Order> getOrdersFallback(Long userId, Exception e) {\n        // Fallback logic\n        return Collections.emptyList();\n    }\n}\n\n// 6. Load Balanced RestTemplate\n@Configuration\npublic class RestTemplateConfig {\n    \n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n\n// 7. Distributed Tracing\n// application.yml\nspring:\n  zipkin:\n    base-url: http://localhost:9411\n  sleuth:\n    sampler:\n      probability: 1.0\n\n// Docker Compose\nversion: '3'\nservices:\n  eureka-server:\n    image: eureka-server:latest\n    ports:\n      - \"8761:8761\"\n  \n  user-service:\n    image: user-service:latest\n    depends_on:\n      - eureka-server\n    environment:\n      - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka"
  },

  // How Java Works (Intermediate)
  {
    id: 98,
    category: "How Java Works (Intermediate)",
    question: "Java code qanday compile va execute qilinadi?",
    answer: "Java kod 2 bosqichda ishlaydi: 1) Compilation (Kompilyatsiya) - javac kompilyatori .java faylni .class (bytecode) faylga aylantiradi. Bu bir martalik jarayon. Bytecode - platform-independent, hamma JVM da ishlaydi. 2) Execution (Bajarish) - JVM bytecode ni o'qiydi va mashina kodiga (native code) aylantiradi. Bu har safar dastur ishlaganda sodir bo'ladi. JIT (Just-In-Time) compiler tez-tez ishlatiladigan kodlarni optimize qiladi. Bu 'Write Once, Run Anywhere' (WORA) prinsipi.",
    example: "// 1. Java source code (Hello.java)\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n\n// 2. Compilation\n// Terminal: javac Hello.java\n// Natija: Hello.class (bytecode) yaratiladi\n\n// 3. Execution\n// Terminal: java Hello\n// JVM bytecode ni o'qiydi va ishga tushiradi\n// Output: Hello World\n\n// Full process:\n// .java (source) → javac → .class (bytecode) → JVM → native code → CPU\n\n// Bytecode ko'rinishi (javap -c Hello):\npublic static void main(java.lang.String[]);\n  Code:\n    0: getstatic     #2  // Field java/lang/System.out\n    3: ldc           #3  // String Hello World\n    5: invokevirtual #4  // Method println\n    8: return\n\n// Bir marta compile, istalgan yerda ishla:\n// Windows da compile: javac Hello.java\n// Linux da ishlatish: java Hello  // Ishlaydi!\n// Mac da ishlatish: java Hello    // Ishlaydi!"
  },
  {
    id: 99,
    category: "How Java Works (Intermediate)",
    question: "JIT (Just-In-Time) Compiler nima va qanday ishlaydi?",
    answer: "JIT Compiler - bu bytecode ni runtime da native machine code ga aylantruvchi komponent. Interpretation dan tezroq. JVM avval bytecode ni interpret qiladi (sekin), keyin hot spots (tez-tez ishlatiladigan kod) ni aniqlaydi va ularni native code ga compile qiladi (tez). JIT optimizatsiyalar: inline expansion, dead code elimination, loop unrolling. C1 (Client) compiler - tez compile, kam optimizatsiya. C2 (Server) compiler - sekin compile, ko'p optimizatsiya. Tiered compilation - ikkalasini birlashtiradi.",
    example: "// Method execution lifecycle\npublic int calculateSum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n\n// 1st call: Interpreted (sekin)\ncalculateSum(100);  // ~10ms\n\n// 2nd-10th call: Interpreted\ncalculateSum(100);  // ~10ms har safar\n\n// JVM hot spot aniqlaydi: Bu method ko'p chaqirilmoqda!\n\n// 11th call onwards: JIT compiled (tez)\ncalculateSum(100);  // ~1ms - 10x tezroq!\n\n// JVM flags:\n// -XX:+PrintCompilation  // JIT compilation ni ko'rish\n// -XX:CompileThreshold=10000  // Necha marta chaqirilganda compile qilish\n\n// Tiered Compilation (default Java 8+)\n// Level 0: Interpreter\n// Level 1: C1 with simple optimization\n// Level 2: C1 with full optimization\n// Level 3: C2 compilation"
  },
  {
    id: 100,
    category: "How Java Works (Intermediate)",
    question: "Bytecode nima va nima uchun Java uni ishlatadi?",
    answer: "Bytecode - Java source code ning intermediate (oraliq) ko'rinishi. .class faylda saqlanadi. Platform-independent - Windows, Linux, Mac da bir xil. Human-readable emas, JVM uchun mo'ljallangan. Instructions set: bipush, aload, invokevirtual va boshqalar. Nima uchun bytecode: 1) Platform independence - bir marta compile, hamma yerda ishla. 2) Security - bytecode verifier xavfsizlikni tekshiradi. 3) Optimization - JIT runtime da optimize qiladi. 4) Smaller size - bytecode source code dan kichikroq. javap tool bilan bytecode ni ko'rish mumkin.",
    example: "// Java source code\npublic class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}\n\n// Compile: javac Calculator.java\n// Result: Calculator.class (bytecode)\n\n// View bytecode: javap -c Calculator\npublic int add(int, int);\n  Code:\n    0: iload_1        // Load a from local variable 1\n    1: iload_2        // Load b from local variable 2\n    2: iadd           // Add them\n    3: ireturn        // Return result\n\n// Bytecode instructions:\n// iload: load int from local variable\n// iadd: integer add\n// ireturn: return int\n// invokevirtual: call instance method\n// getstatic: get static field"
  },
  {
    id: 101,
    category: "How Java Works (Intermediate)",
    question: "ClassLoader va Class Loading jarayoni qanday ishlaydi?",
    answer: "ClassLoader - JVM ga class larni yuklash uchun javobgar komponent. 3 bosqich: 1) Loading - .class faylni topish va o'qish. 2) Linking - Verification (bytecode to'g'rimi?), Preparation (static fieldlar uchun joy), Resolution (symbolic reference → direct reference). 3) Initialization - static initializer va static fieldlar. ClassLoader hierarchy: Bootstrap (JDK core classes), Platform/Extension (extension classes), Application (classpath). Delegation model: parent ga avval so'raydi. Lazy loading: class faqat kerak bo'lganda yuklanadi. Custom ClassLoader yaratish mumkin.",
    example: "// ClassLoader hierarchy\nClassLoader appLoader = MyClass.class.getClassLoader();\nSystem.out.println(\"App: \" + appLoader);\n\nClassLoader platformLoader = appLoader.getParent();\nSystem.out.println(\"Platform: \" + platformLoader);\n\nClassLoader bootstrapLoader = platformLoader.getParent();\nSystem.out.println(\"Bootstrap: \" + bootstrapLoader);  // null\n\n// Class initialization order\nclass Parent {\n    static { System.out.println(\"1. Parent static\"); }\n    { System.out.println(\"3. Parent instance\"); }\n    Parent() { System.out.println(\"4. Parent constructor\"); }\n}\n\nclass Child extends Parent {\n    static { System.out.println(\"2. Child static\"); }\n    { System.out.println(\"5. Child instance\"); }\n    Child() { System.out.println(\"6. Child constructor\"); }\n}\n\nnew Child();"
  },
  {
    id: 102,
    category: "How Java Works (Intermediate)",
    question: "CLASSPATH va Package system qanday ishlaydi?",
    answer: "CLASSPATH - JVM va Java compiler class larni qayerdan topishini bildiradi. Directory yoki JAR fayllar ro'yxati. Package - class larni mantiqiy guruhlash mexanizmi. Namespace saqlab qoladi - bir xil nomli classlar turli package larda bo'lishi mumkin. Package hierarchiya directory structure ga mos kelishi kerak. CLASSPATH sozlash: environment variable, -cp flag, manifest file (JAR). Fully Qualified Name (FQN): package.name.ClassName. import statement FQN ni qisqartiradi.",
    example: "// Package declaration\npackage com.example.myapp.models;\n\npublic class User {\n    private String name;\n}\n\n// Directory structure MUST match:\n// com/example/myapp/models/User.java\n\n// Using package\nimport com.example.myapp.models.User;\n\npublic class Main {\n    public static void main(String[] args) {\n        User user = new User();  // With import\n        \n        // Without import (FQN)\n        com.example.myapp.models.User user2 = \n            new com.example.myapp.models.User();\n    }\n}\n\n// CLASSPATH\n// Unix: export CLASSPATH=/path/to/classes:/path/to/lib.jar:.\n// Windows: set CLASSPATH=C:\\path\\to\\classes;lib.jar;.\n// Command: javac -cp \".:/path/to/lib.jar\" MyClass.java"
  },
  {
    id: 103,
    category: "How Java Works (Intermediate)",
    question: "JAR (Java Archive) file nima va qanday yaratiladi?",
    answer: "JAR file - Java class files, metadata va resurslarni bitta arxiv faylga jamlash. ZIP format asosida. Foydalanish: 1) Distribution - dasturni tarqatish oson. 2) Classpath - bitta JAR faylni classpath ga qo'shish. 3) Executable - java -jar orqali ishga tushirish. 4) Library - boshqa loyihalarda qayta ishlatish. JAR tarkibi: .class fayllar, META-INF/MANIFEST.MF, resurslar (images, config). jar command bilan yaratiladi. Maven/Gradle avtomatik JAR yaratadi. Executable JAR Main-Class ko'rsatishi kerak.",
    example: "// JAR yaratish\n// 1. Compile\njavac -d bin src/com/example/*.java\n\n// 2. Create JAR\njar cvf myapp.jar -C bin .\n\n// JAR strukturasi:\n// myapp.jar\n//   META-INF/MANIFEST.MF\n//   com/example/Main.class\n//   resources/config.properties\n\n// MANIFEST.MF\n// Main-Class: com.example.Main\n// Class-Path: lib/mysql.jar lib/gson.jar\n\n// Executable JAR\njar cvfe myapp.jar com.example.Main -C bin .\n\n// Run\njava -jar myapp.jar\n\n// View contents\njar tf myapp.jar"
  },
  {
    id: 104,
    category: "How Java Works (Intermediate)",
    question: "Java Platform Independence qanday amalga oshiriladi?",
    answer: "Java 'Write Once, Run Anywhere' (WORA) prinsipi bilan ishlaydi. Platform independence: 1) Bytecode - platform-neutral intermediate representation. 2) JVM - har bir platform uchun alohida JVM, lekin bytecode bir xil. 3) Standard Library - platform-independent API (java.io, java.nio). 4) Primitive types - har platformda bir xil size (int har doim 32-bit). C/C++ dan farqi: C/C++ to'g'ridan-to'g'ri native code ga compile qilinadi va har platformda qayta compile kerak. Java bir marta compile, istalgan JVM da ishla.",
    example: "// Java Platform Independence\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n\n// Compile once:\njavac HelloWorld.java  // → HelloWorld.class\n\n// Run anywhere:\n// Windows: java HelloWorld  ✓\n// Linux:   java HelloWorld  ✓\n// Mac:     java HelloWorld  ✓\n\n// JVM handles platform differences\nFile file = new File(\"data/file.txt\");\n// Windows: data\\file.txt\n// Unix:    data/file.txt\n// JVM automatically handles this!\n\n// Primitive types always same size\nint x = 100;  // Always 32-bit\n// C/C++: int size varies (16 or 32-bit)\n\nlong y = 1000L;  // Always 64-bit\n// C/C++: long size varies by platform"
  },
  {
    id: 105,
    category: "How Java Works (Intermediate)",
    question: "Java Program Execution Flow to'liq jarayoni qanday?",
    answer: "Java dasturni ishga tushirish to'liq jarayoni: 1) Source Code (.java) - dasturchi yozadi. 2) Compilation (javac) - source code → bytecode (.class). 3) Class Loading - ClassLoader bytecode ni memory ga yuklaydi. 4) Bytecode Verification - security tekshiruvi. 5) JIT Compilation - hot code → native code. 6) Execution - CPU dasturni bajaradi. 7) Garbage Collection - memory tozalash. Har bir bosqichda JVM xavfsizlik, optimizatsiya va platform independence ni ta'minlaydi. Main method dan boshlanadi va return qilguncha yoki exception yuzaga kelguncha davom etadi.",
    example: "// Complete Java Execution Flow\npublic class HelloWorld {\n    static {\n        System.out.println(\"1. Static initializer\");\n    }\n    \n    public HelloWorld() {\n        System.out.println(\"3. Constructor\");\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"2. Main method start\");\n        HelloWorld obj = new HelloWorld();\n        obj.greet();\n        System.out.println(\"5. Main method end\");\n    }\n    \n    public void greet() {\n        System.out.println(\"4. Instance method\");\n    }\n}\n\n// Execution steps:\n// 1. JVM starts\n// 2. ClassLoader loads HelloWorld.class\n// 3. Bytecode verification\n// 4. Static initializers execute\n// 5. main() method called\n// 6. Object creation\n// 7. Method calls\n// 8. GC runs (background)\n// 9. JVM shutdown"
  }
];
